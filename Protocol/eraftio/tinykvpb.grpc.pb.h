// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: tinykvpb.proto
#ifndef GRPC_tinykvpb_2eproto__INCLUDED
#define GRPC_tinykvpb_2eproto__INCLUDED

#include "tinykvpb.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class CompletionQueue;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc

namespace tinykvpb {

// Serve as a distributed kv database. See the request and response definitions in
// kvrpcpb.proto
class TinyKv final {
 public:
  static constexpr char const* service_full_name() {
    return "tinykvpb.TinyKv";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // KV commands with mvcc/txn supported.
    virtual ::grpc::Status KvGet(::grpc::ClientContext* context, const ::kvrpcpb::GetRequest& request, ::kvrpcpb::GetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::GetResponse>> AsyncKvGet(::grpc::ClientContext* context, const ::kvrpcpb::GetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::GetResponse>>(AsyncKvGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::GetResponse>> PrepareAsyncKvGet(::grpc::ClientContext* context, const ::kvrpcpb::GetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::GetResponse>>(PrepareAsyncKvGetRaw(context, request, cq));
    }
    virtual ::grpc::Status KvScan(::grpc::ClientContext* context, const ::kvrpcpb::ScanRequest& request, ::kvrpcpb::ScanResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::ScanResponse>> AsyncKvScan(::grpc::ClientContext* context, const ::kvrpcpb::ScanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::ScanResponse>>(AsyncKvScanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::ScanResponse>> PrepareAsyncKvScan(::grpc::ClientContext* context, const ::kvrpcpb::ScanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::ScanResponse>>(PrepareAsyncKvScanRaw(context, request, cq));
    }
    virtual ::grpc::Status KvPrewrite(::grpc::ClientContext* context, const ::kvrpcpb::PrewriteRequest& request, ::kvrpcpb::PrewriteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::PrewriteResponse>> AsyncKvPrewrite(::grpc::ClientContext* context, const ::kvrpcpb::PrewriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::PrewriteResponse>>(AsyncKvPrewriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::PrewriteResponse>> PrepareAsyncKvPrewrite(::grpc::ClientContext* context, const ::kvrpcpb::PrewriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::PrewriteResponse>>(PrepareAsyncKvPrewriteRaw(context, request, cq));
    }
    virtual ::grpc::Status KvCommit(::grpc::ClientContext* context, const ::kvrpcpb::CommitRequest& request, ::kvrpcpb::CommitResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::CommitResponse>> AsyncKvCommit(::grpc::ClientContext* context, const ::kvrpcpb::CommitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::CommitResponse>>(AsyncKvCommitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::CommitResponse>> PrepareAsyncKvCommit(::grpc::ClientContext* context, const ::kvrpcpb::CommitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::CommitResponse>>(PrepareAsyncKvCommitRaw(context, request, cq));
    }
    virtual ::grpc::Status KvCheckTxnStatus(::grpc::ClientContext* context, const ::kvrpcpb::CheckTxnStatusRequest& request, ::kvrpcpb::CheckTxnStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::CheckTxnStatusResponse>> AsyncKvCheckTxnStatus(::grpc::ClientContext* context, const ::kvrpcpb::CheckTxnStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::CheckTxnStatusResponse>>(AsyncKvCheckTxnStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::CheckTxnStatusResponse>> PrepareAsyncKvCheckTxnStatus(::grpc::ClientContext* context, const ::kvrpcpb::CheckTxnStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::CheckTxnStatusResponse>>(PrepareAsyncKvCheckTxnStatusRaw(context, request, cq));
    }
    virtual ::grpc::Status KvBatchRollback(::grpc::ClientContext* context, const ::kvrpcpb::BatchRollbackRequest& request, ::kvrpcpb::BatchRollbackResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::BatchRollbackResponse>> AsyncKvBatchRollback(::grpc::ClientContext* context, const ::kvrpcpb::BatchRollbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::BatchRollbackResponse>>(AsyncKvBatchRollbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::BatchRollbackResponse>> PrepareAsyncKvBatchRollback(::grpc::ClientContext* context, const ::kvrpcpb::BatchRollbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::BatchRollbackResponse>>(PrepareAsyncKvBatchRollbackRaw(context, request, cq));
    }
    virtual ::grpc::Status KvResolveLock(::grpc::ClientContext* context, const ::kvrpcpb::ResolveLockRequest& request, ::kvrpcpb::ResolveLockResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::ResolveLockResponse>> AsyncKvResolveLock(::grpc::ClientContext* context, const ::kvrpcpb::ResolveLockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::ResolveLockResponse>>(AsyncKvResolveLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::ResolveLockResponse>> PrepareAsyncKvResolveLock(::grpc::ClientContext* context, const ::kvrpcpb::ResolveLockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::ResolveLockResponse>>(PrepareAsyncKvResolveLockRaw(context, request, cq));
    }
    // transfer leader request
    virtual ::grpc::Status TransferLeader(::grpc::ClientContext* context, const ::raft_cmdpb::TransferLeaderRequest& request, ::raft_cmdpb::TransferLeaderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::TransferLeaderResponse>> AsyncTransferLeader(::grpc::ClientContext* context, const ::raft_cmdpb::TransferLeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::TransferLeaderResponse>>(AsyncTransferLeaderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::TransferLeaderResponse>> PrepareAsyncTransferLeader(::grpc::ClientContext* context, const ::raft_cmdpb::TransferLeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::TransferLeaderResponse>>(PrepareAsyncTransferLeaderRaw(context, request, cq));
    }
    // conf change request
    virtual ::grpc::Status PeerConfChange(::grpc::ClientContext* context, const ::raft_cmdpb::ChangePeerRequest& request, ::raft_cmdpb::ChangePeerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::ChangePeerResponse>> AsyncPeerConfChange(::grpc::ClientContext* context, const ::raft_cmdpb::ChangePeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::ChangePeerResponse>>(AsyncPeerConfChangeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::ChangePeerResponse>> PrepareAsyncPeerConfChange(::grpc::ClientContext* context, const ::raft_cmdpb::ChangePeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::ChangePeerResponse>>(PrepareAsyncPeerConfChangeRaw(context, request, cq));
    }
    // split segion request
    virtual ::grpc::Status SplitRegion(::grpc::ClientContext* context, const ::raft_cmdpb::SplitRequest& request, ::raft_cmdpb::SplitResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::SplitResponse>> AsyncSplitRegion(::grpc::ClientContext* context, const ::raft_cmdpb::SplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::SplitResponse>>(AsyncSplitRegionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::SplitResponse>> PrepareAsyncSplitRegion(::grpc::ClientContext* context, const ::raft_cmdpb::SplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::SplitResponse>>(PrepareAsyncSplitRegionRaw(context, request, cq));
    }
    // RawKV commands.
    virtual ::grpc::Status RawGet(::grpc::ClientContext* context, const ::kvrpcpb::RawGetRequest& request, ::kvrpcpb::RawGetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawGetResponse>> AsyncRawGet(::grpc::ClientContext* context, const ::kvrpcpb::RawGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawGetResponse>>(AsyncRawGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawGetResponse>> PrepareAsyncRawGet(::grpc::ClientContext* context, const ::kvrpcpb::RawGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawGetResponse>>(PrepareAsyncRawGetRaw(context, request, cq));
    }
    virtual ::grpc::Status RawPut(::grpc::ClientContext* context, const ::kvrpcpb::RawPutRequest& request, ::kvrpcpb::RawPutResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawPutResponse>> AsyncRawPut(::grpc::ClientContext* context, const ::kvrpcpb::RawPutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawPutResponse>>(AsyncRawPutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawPutResponse>> PrepareAsyncRawPut(::grpc::ClientContext* context, const ::kvrpcpb::RawPutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawPutResponse>>(PrepareAsyncRawPutRaw(context, request, cq));
    }
    virtual ::grpc::Status RawDelete(::grpc::ClientContext* context, const ::kvrpcpb::RawDeleteRequest& request, ::kvrpcpb::RawDeleteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawDeleteResponse>> AsyncRawDelete(::grpc::ClientContext* context, const ::kvrpcpb::RawDeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawDeleteResponse>>(AsyncRawDeleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawDeleteResponse>> PrepareAsyncRawDelete(::grpc::ClientContext* context, const ::kvrpcpb::RawDeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawDeleteResponse>>(PrepareAsyncRawDeleteRaw(context, request, cq));
    }
    virtual ::grpc::Status RawScan(::grpc::ClientContext* context, const ::kvrpcpb::RawScanRequest& request, ::kvrpcpb::RawScanResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawScanResponse>> AsyncRawScan(::grpc::ClientContext* context, const ::kvrpcpb::RawScanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawScanResponse>>(AsyncRawScanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawScanResponse>> PrepareAsyncRawScan(::grpc::ClientContext* context, const ::kvrpcpb::RawScanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawScanResponse>>(PrepareAsyncRawScanRaw(context, request, cq));
    }
    // Raft commands (tinykv <-> tinykv).
    virtual ::grpc::Status Raft(::grpc::ClientContext* context, const ::raft_serverpb::RaftMessage& request, ::raft_serverpb::Done* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_serverpb::Done>> AsyncRaft(::grpc::ClientContext* context, const ::raft_serverpb::RaftMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_serverpb::Done>>(AsyncRaftRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_serverpb::Done>> PrepareAsyncRaft(::grpc::ClientContext* context, const ::raft_serverpb::RaftMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_serverpb::Done>>(PrepareAsyncRaftRaw(context, request, cq));
    }
    virtual ::grpc::Status Snapshot(::grpc::ClientContext* context, const ::raft_serverpb::SnapshotChunk& request, ::raft_serverpb::Done* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_serverpb::Done>> AsyncSnapshot(::grpc::ClientContext* context, const ::raft_serverpb::SnapshotChunk& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_serverpb::Done>>(AsyncSnapshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_serverpb::Done>> PrepareAsyncSnapshot(::grpc::ClientContext* context, const ::raft_serverpb::SnapshotChunk& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::raft_serverpb::Done>>(PrepareAsyncSnapshotRaw(context, request, cq));
    }
    // Coprocessor 
    virtual ::grpc::Status Coprocessor(::grpc::ClientContext* context, const ::coprocessor::Request& request, ::coprocessor::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::coprocessor::Response>> AsyncCoprocessor(::grpc::ClientContext* context, const ::coprocessor::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::coprocessor::Response>>(AsyncCoprocessorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::coprocessor::Response>> PrepareAsyncCoprocessor(::grpc::ClientContext* context, const ::coprocessor::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::coprocessor::Response>>(PrepareAsyncCoprocessorRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // KV commands with mvcc/txn supported.
      virtual void KvGet(::grpc::ClientContext* context, const ::kvrpcpb::GetRequest* request, ::kvrpcpb::GetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::GetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvGet(::grpc::ClientContext* context, const ::kvrpcpb::GetRequest* request, ::kvrpcpb::GetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void KvGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::GetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void KvScan(::grpc::ClientContext* context, const ::kvrpcpb::ScanRequest* request, ::kvrpcpb::ScanResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvScan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::ScanResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvScan(::grpc::ClientContext* context, const ::kvrpcpb::ScanRequest* request, ::kvrpcpb::ScanResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void KvScan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::ScanResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void KvPrewrite(::grpc::ClientContext* context, const ::kvrpcpb::PrewriteRequest* request, ::kvrpcpb::PrewriteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvPrewrite(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::PrewriteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvPrewrite(::grpc::ClientContext* context, const ::kvrpcpb::PrewriteRequest* request, ::kvrpcpb::PrewriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void KvPrewrite(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::PrewriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void KvCommit(::grpc::ClientContext* context, const ::kvrpcpb::CommitRequest* request, ::kvrpcpb::CommitResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvCommit(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::CommitResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvCommit(::grpc::ClientContext* context, const ::kvrpcpb::CommitRequest* request, ::kvrpcpb::CommitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void KvCommit(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::CommitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void KvCheckTxnStatus(::grpc::ClientContext* context, const ::kvrpcpb::CheckTxnStatusRequest* request, ::kvrpcpb::CheckTxnStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvCheckTxnStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::CheckTxnStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvCheckTxnStatus(::grpc::ClientContext* context, const ::kvrpcpb::CheckTxnStatusRequest* request, ::kvrpcpb::CheckTxnStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void KvCheckTxnStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::CheckTxnStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void KvBatchRollback(::grpc::ClientContext* context, const ::kvrpcpb::BatchRollbackRequest* request, ::kvrpcpb::BatchRollbackResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvBatchRollback(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::BatchRollbackResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvBatchRollback(::grpc::ClientContext* context, const ::kvrpcpb::BatchRollbackRequest* request, ::kvrpcpb::BatchRollbackResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void KvBatchRollback(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::BatchRollbackResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void KvResolveLock(::grpc::ClientContext* context, const ::kvrpcpb::ResolveLockRequest* request, ::kvrpcpb::ResolveLockResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvResolveLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::ResolveLockResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvResolveLock(::grpc::ClientContext* context, const ::kvrpcpb::ResolveLockRequest* request, ::kvrpcpb::ResolveLockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void KvResolveLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::ResolveLockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // transfer leader request
      virtual void TransferLeader(::grpc::ClientContext* context, const ::raft_cmdpb::TransferLeaderRequest* request, ::raft_cmdpb::TransferLeaderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TransferLeader(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_cmdpb::TransferLeaderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TransferLeader(::grpc::ClientContext* context, const ::raft_cmdpb::TransferLeaderRequest* request, ::raft_cmdpb::TransferLeaderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void TransferLeader(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_cmdpb::TransferLeaderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // conf change request
      virtual void PeerConfChange(::grpc::ClientContext* context, const ::raft_cmdpb::ChangePeerRequest* request, ::raft_cmdpb::ChangePeerResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PeerConfChange(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_cmdpb::ChangePeerResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PeerConfChange(::grpc::ClientContext* context, const ::raft_cmdpb::ChangePeerRequest* request, ::raft_cmdpb::ChangePeerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void PeerConfChange(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_cmdpb::ChangePeerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // split segion request
      virtual void SplitRegion(::grpc::ClientContext* context, const ::raft_cmdpb::SplitRequest* request, ::raft_cmdpb::SplitResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SplitRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_cmdpb::SplitResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SplitRegion(::grpc::ClientContext* context, const ::raft_cmdpb::SplitRequest* request, ::raft_cmdpb::SplitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SplitRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_cmdpb::SplitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // RawKV commands.
      virtual void RawGet(::grpc::ClientContext* context, const ::kvrpcpb::RawGetRequest* request, ::kvrpcpb::RawGetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RawGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::RawGetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RawGet(::grpc::ClientContext* context, const ::kvrpcpb::RawGetRequest* request, ::kvrpcpb::RawGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RawGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::RawGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RawPut(::grpc::ClientContext* context, const ::kvrpcpb::RawPutRequest* request, ::kvrpcpb::RawPutResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RawPut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::RawPutResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RawPut(::grpc::ClientContext* context, const ::kvrpcpb::RawPutRequest* request, ::kvrpcpb::RawPutResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RawPut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::RawPutResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RawDelete(::grpc::ClientContext* context, const ::kvrpcpb::RawDeleteRequest* request, ::kvrpcpb::RawDeleteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RawDelete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::RawDeleteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RawDelete(::grpc::ClientContext* context, const ::kvrpcpb::RawDeleteRequest* request, ::kvrpcpb::RawDeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RawDelete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::RawDeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RawScan(::grpc::ClientContext* context, const ::kvrpcpb::RawScanRequest* request, ::kvrpcpb::RawScanResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RawScan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::RawScanResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RawScan(::grpc::ClientContext* context, const ::kvrpcpb::RawScanRequest* request, ::kvrpcpb::RawScanResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RawScan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::RawScanResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Raft commands (tinykv <-> tinykv).
      virtual void Raft(::grpc::ClientContext* context, const ::raft_serverpb::RaftMessage* request, ::raft_serverpb::Done* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Raft(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_serverpb::Done* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Raft(::grpc::ClientContext* context, const ::raft_serverpb::RaftMessage* request, ::raft_serverpb::Done* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Raft(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_serverpb::Done* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Snapshot(::grpc::ClientContext* context, const ::raft_serverpb::SnapshotChunk* request, ::raft_serverpb::Done* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Snapshot(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_serverpb::Done* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Snapshot(::grpc::ClientContext* context, const ::raft_serverpb::SnapshotChunk* request, ::raft_serverpb::Done* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Snapshot(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_serverpb::Done* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Coprocessor 
      virtual void Coprocessor(::grpc::ClientContext* context, const ::coprocessor::Request* request, ::coprocessor::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Coprocessor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::coprocessor::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Coprocessor(::grpc::ClientContext* context, const ::coprocessor::Request* request, ::coprocessor::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Coprocessor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::coprocessor::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::GetResponse>* AsyncKvGetRaw(::grpc::ClientContext* context, const ::kvrpcpb::GetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::GetResponse>* PrepareAsyncKvGetRaw(::grpc::ClientContext* context, const ::kvrpcpb::GetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::ScanResponse>* AsyncKvScanRaw(::grpc::ClientContext* context, const ::kvrpcpb::ScanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::ScanResponse>* PrepareAsyncKvScanRaw(::grpc::ClientContext* context, const ::kvrpcpb::ScanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::PrewriteResponse>* AsyncKvPrewriteRaw(::grpc::ClientContext* context, const ::kvrpcpb::PrewriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::PrewriteResponse>* PrepareAsyncKvPrewriteRaw(::grpc::ClientContext* context, const ::kvrpcpb::PrewriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::CommitResponse>* AsyncKvCommitRaw(::grpc::ClientContext* context, const ::kvrpcpb::CommitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::CommitResponse>* PrepareAsyncKvCommitRaw(::grpc::ClientContext* context, const ::kvrpcpb::CommitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::CheckTxnStatusResponse>* AsyncKvCheckTxnStatusRaw(::grpc::ClientContext* context, const ::kvrpcpb::CheckTxnStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::CheckTxnStatusResponse>* PrepareAsyncKvCheckTxnStatusRaw(::grpc::ClientContext* context, const ::kvrpcpb::CheckTxnStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::BatchRollbackResponse>* AsyncKvBatchRollbackRaw(::grpc::ClientContext* context, const ::kvrpcpb::BatchRollbackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::BatchRollbackResponse>* PrepareAsyncKvBatchRollbackRaw(::grpc::ClientContext* context, const ::kvrpcpb::BatchRollbackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::ResolveLockResponse>* AsyncKvResolveLockRaw(::grpc::ClientContext* context, const ::kvrpcpb::ResolveLockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::ResolveLockResponse>* PrepareAsyncKvResolveLockRaw(::grpc::ClientContext* context, const ::kvrpcpb::ResolveLockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::TransferLeaderResponse>* AsyncTransferLeaderRaw(::grpc::ClientContext* context, const ::raft_cmdpb::TransferLeaderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::TransferLeaderResponse>* PrepareAsyncTransferLeaderRaw(::grpc::ClientContext* context, const ::raft_cmdpb::TransferLeaderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::ChangePeerResponse>* AsyncPeerConfChangeRaw(::grpc::ClientContext* context, const ::raft_cmdpb::ChangePeerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::ChangePeerResponse>* PrepareAsyncPeerConfChangeRaw(::grpc::ClientContext* context, const ::raft_cmdpb::ChangePeerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::SplitResponse>* AsyncSplitRegionRaw(::grpc::ClientContext* context, const ::raft_cmdpb::SplitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::raft_cmdpb::SplitResponse>* PrepareAsyncSplitRegionRaw(::grpc::ClientContext* context, const ::raft_cmdpb::SplitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawGetResponse>* AsyncRawGetRaw(::grpc::ClientContext* context, const ::kvrpcpb::RawGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawGetResponse>* PrepareAsyncRawGetRaw(::grpc::ClientContext* context, const ::kvrpcpb::RawGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawPutResponse>* AsyncRawPutRaw(::grpc::ClientContext* context, const ::kvrpcpb::RawPutRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawPutResponse>* PrepareAsyncRawPutRaw(::grpc::ClientContext* context, const ::kvrpcpb::RawPutRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawDeleteResponse>* AsyncRawDeleteRaw(::grpc::ClientContext* context, const ::kvrpcpb::RawDeleteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawDeleteResponse>* PrepareAsyncRawDeleteRaw(::grpc::ClientContext* context, const ::kvrpcpb::RawDeleteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawScanResponse>* AsyncRawScanRaw(::grpc::ClientContext* context, const ::kvrpcpb::RawScanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kvrpcpb::RawScanResponse>* PrepareAsyncRawScanRaw(::grpc::ClientContext* context, const ::kvrpcpb::RawScanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::raft_serverpb::Done>* AsyncRaftRaw(::grpc::ClientContext* context, const ::raft_serverpb::RaftMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::raft_serverpb::Done>* PrepareAsyncRaftRaw(::grpc::ClientContext* context, const ::raft_serverpb::RaftMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::raft_serverpb::Done>* AsyncSnapshotRaw(::grpc::ClientContext* context, const ::raft_serverpb::SnapshotChunk& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::raft_serverpb::Done>* PrepareAsyncSnapshotRaw(::grpc::ClientContext* context, const ::raft_serverpb::SnapshotChunk& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::coprocessor::Response>* AsyncCoprocessorRaw(::grpc::ClientContext* context, const ::coprocessor::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::coprocessor::Response>* PrepareAsyncCoprocessorRaw(::grpc::ClientContext* context, const ::coprocessor::Request& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status KvGet(::grpc::ClientContext* context, const ::kvrpcpb::GetRequest& request, ::kvrpcpb::GetResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::GetResponse>> AsyncKvGet(::grpc::ClientContext* context, const ::kvrpcpb::GetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::GetResponse>>(AsyncKvGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::GetResponse>> PrepareAsyncKvGet(::grpc::ClientContext* context, const ::kvrpcpb::GetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::GetResponse>>(PrepareAsyncKvGetRaw(context, request, cq));
    }
    ::grpc::Status KvScan(::grpc::ClientContext* context, const ::kvrpcpb::ScanRequest& request, ::kvrpcpb::ScanResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::ScanResponse>> AsyncKvScan(::grpc::ClientContext* context, const ::kvrpcpb::ScanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::ScanResponse>>(AsyncKvScanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::ScanResponse>> PrepareAsyncKvScan(::grpc::ClientContext* context, const ::kvrpcpb::ScanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::ScanResponse>>(PrepareAsyncKvScanRaw(context, request, cq));
    }
    ::grpc::Status KvPrewrite(::grpc::ClientContext* context, const ::kvrpcpb::PrewriteRequest& request, ::kvrpcpb::PrewriteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::PrewriteResponse>> AsyncKvPrewrite(::grpc::ClientContext* context, const ::kvrpcpb::PrewriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::PrewriteResponse>>(AsyncKvPrewriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::PrewriteResponse>> PrepareAsyncKvPrewrite(::grpc::ClientContext* context, const ::kvrpcpb::PrewriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::PrewriteResponse>>(PrepareAsyncKvPrewriteRaw(context, request, cq));
    }
    ::grpc::Status KvCommit(::grpc::ClientContext* context, const ::kvrpcpb::CommitRequest& request, ::kvrpcpb::CommitResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::CommitResponse>> AsyncKvCommit(::grpc::ClientContext* context, const ::kvrpcpb::CommitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::CommitResponse>>(AsyncKvCommitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::CommitResponse>> PrepareAsyncKvCommit(::grpc::ClientContext* context, const ::kvrpcpb::CommitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::CommitResponse>>(PrepareAsyncKvCommitRaw(context, request, cq));
    }
    ::grpc::Status KvCheckTxnStatus(::grpc::ClientContext* context, const ::kvrpcpb::CheckTxnStatusRequest& request, ::kvrpcpb::CheckTxnStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::CheckTxnStatusResponse>> AsyncKvCheckTxnStatus(::grpc::ClientContext* context, const ::kvrpcpb::CheckTxnStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::CheckTxnStatusResponse>>(AsyncKvCheckTxnStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::CheckTxnStatusResponse>> PrepareAsyncKvCheckTxnStatus(::grpc::ClientContext* context, const ::kvrpcpb::CheckTxnStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::CheckTxnStatusResponse>>(PrepareAsyncKvCheckTxnStatusRaw(context, request, cq));
    }
    ::grpc::Status KvBatchRollback(::grpc::ClientContext* context, const ::kvrpcpb::BatchRollbackRequest& request, ::kvrpcpb::BatchRollbackResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::BatchRollbackResponse>> AsyncKvBatchRollback(::grpc::ClientContext* context, const ::kvrpcpb::BatchRollbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::BatchRollbackResponse>>(AsyncKvBatchRollbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::BatchRollbackResponse>> PrepareAsyncKvBatchRollback(::grpc::ClientContext* context, const ::kvrpcpb::BatchRollbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::BatchRollbackResponse>>(PrepareAsyncKvBatchRollbackRaw(context, request, cq));
    }
    ::grpc::Status KvResolveLock(::grpc::ClientContext* context, const ::kvrpcpb::ResolveLockRequest& request, ::kvrpcpb::ResolveLockResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::ResolveLockResponse>> AsyncKvResolveLock(::grpc::ClientContext* context, const ::kvrpcpb::ResolveLockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::ResolveLockResponse>>(AsyncKvResolveLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::ResolveLockResponse>> PrepareAsyncKvResolveLock(::grpc::ClientContext* context, const ::kvrpcpb::ResolveLockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::ResolveLockResponse>>(PrepareAsyncKvResolveLockRaw(context, request, cq));
    }
    ::grpc::Status TransferLeader(::grpc::ClientContext* context, const ::raft_cmdpb::TransferLeaderRequest& request, ::raft_cmdpb::TransferLeaderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::TransferLeaderResponse>> AsyncTransferLeader(::grpc::ClientContext* context, const ::raft_cmdpb::TransferLeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::TransferLeaderResponse>>(AsyncTransferLeaderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::TransferLeaderResponse>> PrepareAsyncTransferLeader(::grpc::ClientContext* context, const ::raft_cmdpb::TransferLeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::TransferLeaderResponse>>(PrepareAsyncTransferLeaderRaw(context, request, cq));
    }
    ::grpc::Status PeerConfChange(::grpc::ClientContext* context, const ::raft_cmdpb::ChangePeerRequest& request, ::raft_cmdpb::ChangePeerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::ChangePeerResponse>> AsyncPeerConfChange(::grpc::ClientContext* context, const ::raft_cmdpb::ChangePeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::ChangePeerResponse>>(AsyncPeerConfChangeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::ChangePeerResponse>> PrepareAsyncPeerConfChange(::grpc::ClientContext* context, const ::raft_cmdpb::ChangePeerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::ChangePeerResponse>>(PrepareAsyncPeerConfChangeRaw(context, request, cq));
    }
    ::grpc::Status SplitRegion(::grpc::ClientContext* context, const ::raft_cmdpb::SplitRequest& request, ::raft_cmdpb::SplitResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::SplitResponse>> AsyncSplitRegion(::grpc::ClientContext* context, const ::raft_cmdpb::SplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::SplitResponse>>(AsyncSplitRegionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::SplitResponse>> PrepareAsyncSplitRegion(::grpc::ClientContext* context, const ::raft_cmdpb::SplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::SplitResponse>>(PrepareAsyncSplitRegionRaw(context, request, cq));
    }
    ::grpc::Status RawGet(::grpc::ClientContext* context, const ::kvrpcpb::RawGetRequest& request, ::kvrpcpb::RawGetResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawGetResponse>> AsyncRawGet(::grpc::ClientContext* context, const ::kvrpcpb::RawGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawGetResponse>>(AsyncRawGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawGetResponse>> PrepareAsyncRawGet(::grpc::ClientContext* context, const ::kvrpcpb::RawGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawGetResponse>>(PrepareAsyncRawGetRaw(context, request, cq));
    }
    ::grpc::Status RawPut(::grpc::ClientContext* context, const ::kvrpcpb::RawPutRequest& request, ::kvrpcpb::RawPutResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawPutResponse>> AsyncRawPut(::grpc::ClientContext* context, const ::kvrpcpb::RawPutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawPutResponse>>(AsyncRawPutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawPutResponse>> PrepareAsyncRawPut(::grpc::ClientContext* context, const ::kvrpcpb::RawPutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawPutResponse>>(PrepareAsyncRawPutRaw(context, request, cq));
    }
    ::grpc::Status RawDelete(::grpc::ClientContext* context, const ::kvrpcpb::RawDeleteRequest& request, ::kvrpcpb::RawDeleteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawDeleteResponse>> AsyncRawDelete(::grpc::ClientContext* context, const ::kvrpcpb::RawDeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawDeleteResponse>>(AsyncRawDeleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawDeleteResponse>> PrepareAsyncRawDelete(::grpc::ClientContext* context, const ::kvrpcpb::RawDeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawDeleteResponse>>(PrepareAsyncRawDeleteRaw(context, request, cq));
    }
    ::grpc::Status RawScan(::grpc::ClientContext* context, const ::kvrpcpb::RawScanRequest& request, ::kvrpcpb::RawScanResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawScanResponse>> AsyncRawScan(::grpc::ClientContext* context, const ::kvrpcpb::RawScanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawScanResponse>>(AsyncRawScanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawScanResponse>> PrepareAsyncRawScan(::grpc::ClientContext* context, const ::kvrpcpb::RawScanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawScanResponse>>(PrepareAsyncRawScanRaw(context, request, cq));
    }
    ::grpc::Status Raft(::grpc::ClientContext* context, const ::raft_serverpb::RaftMessage& request, ::raft_serverpb::Done* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_serverpb::Done>> AsyncRaft(::grpc::ClientContext* context, const ::raft_serverpb::RaftMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_serverpb::Done>>(AsyncRaftRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_serverpb::Done>> PrepareAsyncRaft(::grpc::ClientContext* context, const ::raft_serverpb::RaftMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_serverpb::Done>>(PrepareAsyncRaftRaw(context, request, cq));
    }
    ::grpc::Status Snapshot(::grpc::ClientContext* context, const ::raft_serverpb::SnapshotChunk& request, ::raft_serverpb::Done* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_serverpb::Done>> AsyncSnapshot(::grpc::ClientContext* context, const ::raft_serverpb::SnapshotChunk& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_serverpb::Done>>(AsyncSnapshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_serverpb::Done>> PrepareAsyncSnapshot(::grpc::ClientContext* context, const ::raft_serverpb::SnapshotChunk& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::raft_serverpb::Done>>(PrepareAsyncSnapshotRaw(context, request, cq));
    }
    ::grpc::Status Coprocessor(::grpc::ClientContext* context, const ::coprocessor::Request& request, ::coprocessor::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::coprocessor::Response>> AsyncCoprocessor(::grpc::ClientContext* context, const ::coprocessor::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::coprocessor::Response>>(AsyncCoprocessorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::coprocessor::Response>> PrepareAsyncCoprocessor(::grpc::ClientContext* context, const ::coprocessor::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::coprocessor::Response>>(PrepareAsyncCoprocessorRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void KvGet(::grpc::ClientContext* context, const ::kvrpcpb::GetRequest* request, ::kvrpcpb::GetResponse* response, std::function<void(::grpc::Status)>) override;
      void KvGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::GetResponse* response, std::function<void(::grpc::Status)>) override;
      void KvGet(::grpc::ClientContext* context, const ::kvrpcpb::GetRequest* request, ::kvrpcpb::GetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void KvGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::GetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void KvScan(::grpc::ClientContext* context, const ::kvrpcpb::ScanRequest* request, ::kvrpcpb::ScanResponse* response, std::function<void(::grpc::Status)>) override;
      void KvScan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::ScanResponse* response, std::function<void(::grpc::Status)>) override;
      void KvScan(::grpc::ClientContext* context, const ::kvrpcpb::ScanRequest* request, ::kvrpcpb::ScanResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void KvScan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::ScanResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void KvPrewrite(::grpc::ClientContext* context, const ::kvrpcpb::PrewriteRequest* request, ::kvrpcpb::PrewriteResponse* response, std::function<void(::grpc::Status)>) override;
      void KvPrewrite(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::PrewriteResponse* response, std::function<void(::grpc::Status)>) override;
      void KvPrewrite(::grpc::ClientContext* context, const ::kvrpcpb::PrewriteRequest* request, ::kvrpcpb::PrewriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void KvPrewrite(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::PrewriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void KvCommit(::grpc::ClientContext* context, const ::kvrpcpb::CommitRequest* request, ::kvrpcpb::CommitResponse* response, std::function<void(::grpc::Status)>) override;
      void KvCommit(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::CommitResponse* response, std::function<void(::grpc::Status)>) override;
      void KvCommit(::grpc::ClientContext* context, const ::kvrpcpb::CommitRequest* request, ::kvrpcpb::CommitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void KvCommit(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::CommitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void KvCheckTxnStatus(::grpc::ClientContext* context, const ::kvrpcpb::CheckTxnStatusRequest* request, ::kvrpcpb::CheckTxnStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void KvCheckTxnStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::CheckTxnStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void KvCheckTxnStatus(::grpc::ClientContext* context, const ::kvrpcpb::CheckTxnStatusRequest* request, ::kvrpcpb::CheckTxnStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void KvCheckTxnStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::CheckTxnStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void KvBatchRollback(::grpc::ClientContext* context, const ::kvrpcpb::BatchRollbackRequest* request, ::kvrpcpb::BatchRollbackResponse* response, std::function<void(::grpc::Status)>) override;
      void KvBatchRollback(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::BatchRollbackResponse* response, std::function<void(::grpc::Status)>) override;
      void KvBatchRollback(::grpc::ClientContext* context, const ::kvrpcpb::BatchRollbackRequest* request, ::kvrpcpb::BatchRollbackResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void KvBatchRollback(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::BatchRollbackResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void KvResolveLock(::grpc::ClientContext* context, const ::kvrpcpb::ResolveLockRequest* request, ::kvrpcpb::ResolveLockResponse* response, std::function<void(::grpc::Status)>) override;
      void KvResolveLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::ResolveLockResponse* response, std::function<void(::grpc::Status)>) override;
      void KvResolveLock(::grpc::ClientContext* context, const ::kvrpcpb::ResolveLockRequest* request, ::kvrpcpb::ResolveLockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void KvResolveLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::ResolveLockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void TransferLeader(::grpc::ClientContext* context, const ::raft_cmdpb::TransferLeaderRequest* request, ::raft_cmdpb::TransferLeaderResponse* response, std::function<void(::grpc::Status)>) override;
      void TransferLeader(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_cmdpb::TransferLeaderResponse* response, std::function<void(::grpc::Status)>) override;
      void TransferLeader(::grpc::ClientContext* context, const ::raft_cmdpb::TransferLeaderRequest* request, ::raft_cmdpb::TransferLeaderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void TransferLeader(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_cmdpb::TransferLeaderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void PeerConfChange(::grpc::ClientContext* context, const ::raft_cmdpb::ChangePeerRequest* request, ::raft_cmdpb::ChangePeerResponse* response, std::function<void(::grpc::Status)>) override;
      void PeerConfChange(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_cmdpb::ChangePeerResponse* response, std::function<void(::grpc::Status)>) override;
      void PeerConfChange(::grpc::ClientContext* context, const ::raft_cmdpb::ChangePeerRequest* request, ::raft_cmdpb::ChangePeerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void PeerConfChange(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_cmdpb::ChangePeerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SplitRegion(::grpc::ClientContext* context, const ::raft_cmdpb::SplitRequest* request, ::raft_cmdpb::SplitResponse* response, std::function<void(::grpc::Status)>) override;
      void SplitRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_cmdpb::SplitResponse* response, std::function<void(::grpc::Status)>) override;
      void SplitRegion(::grpc::ClientContext* context, const ::raft_cmdpb::SplitRequest* request, ::raft_cmdpb::SplitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SplitRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_cmdpb::SplitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RawGet(::grpc::ClientContext* context, const ::kvrpcpb::RawGetRequest* request, ::kvrpcpb::RawGetResponse* response, std::function<void(::grpc::Status)>) override;
      void RawGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::RawGetResponse* response, std::function<void(::grpc::Status)>) override;
      void RawGet(::grpc::ClientContext* context, const ::kvrpcpb::RawGetRequest* request, ::kvrpcpb::RawGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RawGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::RawGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RawPut(::grpc::ClientContext* context, const ::kvrpcpb::RawPutRequest* request, ::kvrpcpb::RawPutResponse* response, std::function<void(::grpc::Status)>) override;
      void RawPut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::RawPutResponse* response, std::function<void(::grpc::Status)>) override;
      void RawPut(::grpc::ClientContext* context, const ::kvrpcpb::RawPutRequest* request, ::kvrpcpb::RawPutResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RawPut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::RawPutResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RawDelete(::grpc::ClientContext* context, const ::kvrpcpb::RawDeleteRequest* request, ::kvrpcpb::RawDeleteResponse* response, std::function<void(::grpc::Status)>) override;
      void RawDelete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::RawDeleteResponse* response, std::function<void(::grpc::Status)>) override;
      void RawDelete(::grpc::ClientContext* context, const ::kvrpcpb::RawDeleteRequest* request, ::kvrpcpb::RawDeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RawDelete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::RawDeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RawScan(::grpc::ClientContext* context, const ::kvrpcpb::RawScanRequest* request, ::kvrpcpb::RawScanResponse* response, std::function<void(::grpc::Status)>) override;
      void RawScan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::RawScanResponse* response, std::function<void(::grpc::Status)>) override;
      void RawScan(::grpc::ClientContext* context, const ::kvrpcpb::RawScanRequest* request, ::kvrpcpb::RawScanResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RawScan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::kvrpcpb::RawScanResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Raft(::grpc::ClientContext* context, const ::raft_serverpb::RaftMessage* request, ::raft_serverpb::Done* response, std::function<void(::grpc::Status)>) override;
      void Raft(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_serverpb::Done* response, std::function<void(::grpc::Status)>) override;
      void Raft(::grpc::ClientContext* context, const ::raft_serverpb::RaftMessage* request, ::raft_serverpb::Done* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Raft(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_serverpb::Done* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Snapshot(::grpc::ClientContext* context, const ::raft_serverpb::SnapshotChunk* request, ::raft_serverpb::Done* response, std::function<void(::grpc::Status)>) override;
      void Snapshot(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_serverpb::Done* response, std::function<void(::grpc::Status)>) override;
      void Snapshot(::grpc::ClientContext* context, const ::raft_serverpb::SnapshotChunk* request, ::raft_serverpb::Done* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Snapshot(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::raft_serverpb::Done* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Coprocessor(::grpc::ClientContext* context, const ::coprocessor::Request* request, ::coprocessor::Response* response, std::function<void(::grpc::Status)>) override;
      void Coprocessor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::coprocessor::Response* response, std::function<void(::grpc::Status)>) override;
      void Coprocessor(::grpc::ClientContext* context, const ::coprocessor::Request* request, ::coprocessor::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Coprocessor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::coprocessor::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::GetResponse>* AsyncKvGetRaw(::grpc::ClientContext* context, const ::kvrpcpb::GetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::GetResponse>* PrepareAsyncKvGetRaw(::grpc::ClientContext* context, const ::kvrpcpb::GetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::ScanResponse>* AsyncKvScanRaw(::grpc::ClientContext* context, const ::kvrpcpb::ScanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::ScanResponse>* PrepareAsyncKvScanRaw(::grpc::ClientContext* context, const ::kvrpcpb::ScanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::PrewriteResponse>* AsyncKvPrewriteRaw(::grpc::ClientContext* context, const ::kvrpcpb::PrewriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::PrewriteResponse>* PrepareAsyncKvPrewriteRaw(::grpc::ClientContext* context, const ::kvrpcpb::PrewriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::CommitResponse>* AsyncKvCommitRaw(::grpc::ClientContext* context, const ::kvrpcpb::CommitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::CommitResponse>* PrepareAsyncKvCommitRaw(::grpc::ClientContext* context, const ::kvrpcpb::CommitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::CheckTxnStatusResponse>* AsyncKvCheckTxnStatusRaw(::grpc::ClientContext* context, const ::kvrpcpb::CheckTxnStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::CheckTxnStatusResponse>* PrepareAsyncKvCheckTxnStatusRaw(::grpc::ClientContext* context, const ::kvrpcpb::CheckTxnStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::BatchRollbackResponse>* AsyncKvBatchRollbackRaw(::grpc::ClientContext* context, const ::kvrpcpb::BatchRollbackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::BatchRollbackResponse>* PrepareAsyncKvBatchRollbackRaw(::grpc::ClientContext* context, const ::kvrpcpb::BatchRollbackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::ResolveLockResponse>* AsyncKvResolveLockRaw(::grpc::ClientContext* context, const ::kvrpcpb::ResolveLockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::ResolveLockResponse>* PrepareAsyncKvResolveLockRaw(::grpc::ClientContext* context, const ::kvrpcpb::ResolveLockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::TransferLeaderResponse>* AsyncTransferLeaderRaw(::grpc::ClientContext* context, const ::raft_cmdpb::TransferLeaderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::TransferLeaderResponse>* PrepareAsyncTransferLeaderRaw(::grpc::ClientContext* context, const ::raft_cmdpb::TransferLeaderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::ChangePeerResponse>* AsyncPeerConfChangeRaw(::grpc::ClientContext* context, const ::raft_cmdpb::ChangePeerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::ChangePeerResponse>* PrepareAsyncPeerConfChangeRaw(::grpc::ClientContext* context, const ::raft_cmdpb::ChangePeerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::SplitResponse>* AsyncSplitRegionRaw(::grpc::ClientContext* context, const ::raft_cmdpb::SplitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::raft_cmdpb::SplitResponse>* PrepareAsyncSplitRegionRaw(::grpc::ClientContext* context, const ::raft_cmdpb::SplitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawGetResponse>* AsyncRawGetRaw(::grpc::ClientContext* context, const ::kvrpcpb::RawGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawGetResponse>* PrepareAsyncRawGetRaw(::grpc::ClientContext* context, const ::kvrpcpb::RawGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawPutResponse>* AsyncRawPutRaw(::grpc::ClientContext* context, const ::kvrpcpb::RawPutRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawPutResponse>* PrepareAsyncRawPutRaw(::grpc::ClientContext* context, const ::kvrpcpb::RawPutRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawDeleteResponse>* AsyncRawDeleteRaw(::grpc::ClientContext* context, const ::kvrpcpb::RawDeleteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawDeleteResponse>* PrepareAsyncRawDeleteRaw(::grpc::ClientContext* context, const ::kvrpcpb::RawDeleteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawScanResponse>* AsyncRawScanRaw(::grpc::ClientContext* context, const ::kvrpcpb::RawScanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kvrpcpb::RawScanResponse>* PrepareAsyncRawScanRaw(::grpc::ClientContext* context, const ::kvrpcpb::RawScanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::raft_serverpb::Done>* AsyncRaftRaw(::grpc::ClientContext* context, const ::raft_serverpb::RaftMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::raft_serverpb::Done>* PrepareAsyncRaftRaw(::grpc::ClientContext* context, const ::raft_serverpb::RaftMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::raft_serverpb::Done>* AsyncSnapshotRaw(::grpc::ClientContext* context, const ::raft_serverpb::SnapshotChunk& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::raft_serverpb::Done>* PrepareAsyncSnapshotRaw(::grpc::ClientContext* context, const ::raft_serverpb::SnapshotChunk& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::coprocessor::Response>* AsyncCoprocessorRaw(::grpc::ClientContext* context, const ::coprocessor::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::coprocessor::Response>* PrepareAsyncCoprocessorRaw(::grpc::ClientContext* context, const ::coprocessor::Request& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_KvGet_;
    const ::grpc::internal::RpcMethod rpcmethod_KvScan_;
    const ::grpc::internal::RpcMethod rpcmethod_KvPrewrite_;
    const ::grpc::internal::RpcMethod rpcmethod_KvCommit_;
    const ::grpc::internal::RpcMethod rpcmethod_KvCheckTxnStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_KvBatchRollback_;
    const ::grpc::internal::RpcMethod rpcmethod_KvResolveLock_;
    const ::grpc::internal::RpcMethod rpcmethod_TransferLeader_;
    const ::grpc::internal::RpcMethod rpcmethod_PeerConfChange_;
    const ::grpc::internal::RpcMethod rpcmethod_SplitRegion_;
    const ::grpc::internal::RpcMethod rpcmethod_RawGet_;
    const ::grpc::internal::RpcMethod rpcmethod_RawPut_;
    const ::grpc::internal::RpcMethod rpcmethod_RawDelete_;
    const ::grpc::internal::RpcMethod rpcmethod_RawScan_;
    const ::grpc::internal::RpcMethod rpcmethod_Raft_;
    const ::grpc::internal::RpcMethod rpcmethod_Snapshot_;
    const ::grpc::internal::RpcMethod rpcmethod_Coprocessor_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // KV commands with mvcc/txn supported.
    virtual ::grpc::Status KvGet(::grpc::ServerContext* context, const ::kvrpcpb::GetRequest* request, ::kvrpcpb::GetResponse* response);
    virtual ::grpc::Status KvScan(::grpc::ServerContext* context, const ::kvrpcpb::ScanRequest* request, ::kvrpcpb::ScanResponse* response);
    virtual ::grpc::Status KvPrewrite(::grpc::ServerContext* context, const ::kvrpcpb::PrewriteRequest* request, ::kvrpcpb::PrewriteResponse* response);
    virtual ::grpc::Status KvCommit(::grpc::ServerContext* context, const ::kvrpcpb::CommitRequest* request, ::kvrpcpb::CommitResponse* response);
    virtual ::grpc::Status KvCheckTxnStatus(::grpc::ServerContext* context, const ::kvrpcpb::CheckTxnStatusRequest* request, ::kvrpcpb::CheckTxnStatusResponse* response);
    virtual ::grpc::Status KvBatchRollback(::grpc::ServerContext* context, const ::kvrpcpb::BatchRollbackRequest* request, ::kvrpcpb::BatchRollbackResponse* response);
    virtual ::grpc::Status KvResolveLock(::grpc::ServerContext* context, const ::kvrpcpb::ResolveLockRequest* request, ::kvrpcpb::ResolveLockResponse* response);
    // transfer leader request
    virtual ::grpc::Status TransferLeader(::grpc::ServerContext* context, const ::raft_cmdpb::TransferLeaderRequest* request, ::raft_cmdpb::TransferLeaderResponse* response);
    // conf change request
    virtual ::grpc::Status PeerConfChange(::grpc::ServerContext* context, const ::raft_cmdpb::ChangePeerRequest* request, ::raft_cmdpb::ChangePeerResponse* response);
    // split segion request
    virtual ::grpc::Status SplitRegion(::grpc::ServerContext* context, const ::raft_cmdpb::SplitRequest* request, ::raft_cmdpb::SplitResponse* response);
    // RawKV commands.
    virtual ::grpc::Status RawGet(::grpc::ServerContext* context, const ::kvrpcpb::RawGetRequest* request, ::kvrpcpb::RawGetResponse* response);
    virtual ::grpc::Status RawPut(::grpc::ServerContext* context, const ::kvrpcpb::RawPutRequest* request, ::kvrpcpb::RawPutResponse* response);
    virtual ::grpc::Status RawDelete(::grpc::ServerContext* context, const ::kvrpcpb::RawDeleteRequest* request, ::kvrpcpb::RawDeleteResponse* response);
    virtual ::grpc::Status RawScan(::grpc::ServerContext* context, const ::kvrpcpb::RawScanRequest* request, ::kvrpcpb::RawScanResponse* response);
    // Raft commands (tinykv <-> tinykv).
    virtual ::grpc::Status Raft(::grpc::ServerContext* context, const ::raft_serverpb::RaftMessage* request, ::raft_serverpb::Done* response);
    virtual ::grpc::Status Snapshot(::grpc::ServerContext* context, const ::raft_serverpb::SnapshotChunk* request, ::raft_serverpb::Done* response);
    // Coprocessor 
    virtual ::grpc::Status Coprocessor(::grpc::ServerContext* context, const ::coprocessor::Request* request, ::coprocessor::Response* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_KvGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KvGet() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_KvGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGet(::grpc::ServerContext* /*context*/, const ::kvrpcpb::GetRequest* /*request*/, ::kvrpcpb::GetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvGet(::grpc::ServerContext* context, ::kvrpcpb::GetRequest* request, ::grpc::ServerAsyncResponseWriter< ::kvrpcpb::GetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KvScan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KvScan() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_KvScan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvScan(::grpc::ServerContext* /*context*/, const ::kvrpcpb::ScanRequest* /*request*/, ::kvrpcpb::ScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvScan(::grpc::ServerContext* context, ::kvrpcpb::ScanRequest* request, ::grpc::ServerAsyncResponseWriter< ::kvrpcpb::ScanResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KvPrewrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KvPrewrite() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_KvPrewrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvPrewrite(::grpc::ServerContext* /*context*/, const ::kvrpcpb::PrewriteRequest* /*request*/, ::kvrpcpb::PrewriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvPrewrite(::grpc::ServerContext* context, ::kvrpcpb::PrewriteRequest* request, ::grpc::ServerAsyncResponseWriter< ::kvrpcpb::PrewriteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KvCommit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KvCommit() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_KvCommit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvCommit(::grpc::ServerContext* /*context*/, const ::kvrpcpb::CommitRequest* /*request*/, ::kvrpcpb::CommitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvCommit(::grpc::ServerContext* context, ::kvrpcpb::CommitRequest* request, ::grpc::ServerAsyncResponseWriter< ::kvrpcpb::CommitResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KvCheckTxnStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KvCheckTxnStatus() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_KvCheckTxnStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvCheckTxnStatus(::grpc::ServerContext* /*context*/, const ::kvrpcpb::CheckTxnStatusRequest* /*request*/, ::kvrpcpb::CheckTxnStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvCheckTxnStatus(::grpc::ServerContext* context, ::kvrpcpb::CheckTxnStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::kvrpcpb::CheckTxnStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KvBatchRollback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KvBatchRollback() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_KvBatchRollback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBatchRollback(::grpc::ServerContext* /*context*/, const ::kvrpcpb::BatchRollbackRequest* /*request*/, ::kvrpcpb::BatchRollbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvBatchRollback(::grpc::ServerContext* context, ::kvrpcpb::BatchRollbackRequest* request, ::grpc::ServerAsyncResponseWriter< ::kvrpcpb::BatchRollbackResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KvResolveLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KvResolveLock() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_KvResolveLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvResolveLock(::grpc::ServerContext* /*context*/, const ::kvrpcpb::ResolveLockRequest* /*request*/, ::kvrpcpb::ResolveLockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvResolveLock(::grpc::ServerContext* context, ::kvrpcpb::ResolveLockRequest* request, ::grpc::ServerAsyncResponseWriter< ::kvrpcpb::ResolveLockResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TransferLeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TransferLeader() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_TransferLeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferLeader(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::TransferLeaderRequest* /*request*/, ::raft_cmdpb::TransferLeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransferLeader(::grpc::ServerContext* context, ::raft_cmdpb::TransferLeaderRequest* request, ::grpc::ServerAsyncResponseWriter< ::raft_cmdpb::TransferLeaderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PeerConfChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PeerConfChange() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_PeerConfChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerConfChange(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::ChangePeerRequest* /*request*/, ::raft_cmdpb::ChangePeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeerConfChange(::grpc::ServerContext* context, ::raft_cmdpb::ChangePeerRequest* request, ::grpc::ServerAsyncResponseWriter< ::raft_cmdpb::ChangePeerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SplitRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SplitRegion() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_SplitRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SplitRegion(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::SplitRequest* /*request*/, ::raft_cmdpb::SplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSplitRegion(::grpc::ServerContext* context, ::raft_cmdpb::SplitRequest* request, ::grpc::ServerAsyncResponseWriter< ::raft_cmdpb::SplitResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RawGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RawGet() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_RawGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawGet(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawGetRequest* /*request*/, ::kvrpcpb::RawGetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRawGet(::grpc::ServerContext* context, ::kvrpcpb::RawGetRequest* request, ::grpc::ServerAsyncResponseWriter< ::kvrpcpb::RawGetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RawPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RawPut() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_RawPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawPut(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawPutRequest* /*request*/, ::kvrpcpb::RawPutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRawPut(::grpc::ServerContext* context, ::kvrpcpb::RawPutRequest* request, ::grpc::ServerAsyncResponseWriter< ::kvrpcpb::RawPutResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RawDelete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RawDelete() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_RawDelete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawDelete(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawDeleteRequest* /*request*/, ::kvrpcpb::RawDeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRawDelete(::grpc::ServerContext* context, ::kvrpcpb::RawDeleteRequest* request, ::grpc::ServerAsyncResponseWriter< ::kvrpcpb::RawDeleteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RawScan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RawScan() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_RawScan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawScan(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawScanRequest* /*request*/, ::kvrpcpb::RawScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRawScan(::grpc::ServerContext* context, ::kvrpcpb::RawScanRequest* request, ::grpc::ServerAsyncResponseWriter< ::kvrpcpb::RawScanResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Raft : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Raft() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_Raft() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Raft(::grpc::ServerContext* /*context*/, const ::raft_serverpb::RaftMessage* /*request*/, ::raft_serverpb::Done* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRaft(::grpc::ServerContext* context, ::raft_serverpb::RaftMessage* request, ::grpc::ServerAsyncResponseWriter< ::raft_serverpb::Done>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Snapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Snapshot() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_Snapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Snapshot(::grpc::ServerContext* /*context*/, const ::raft_serverpb::SnapshotChunk* /*request*/, ::raft_serverpb::Done* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSnapshot(::grpc::ServerContext* context, ::raft_serverpb::SnapshotChunk* request, ::grpc::ServerAsyncResponseWriter< ::raft_serverpb::Done>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Coprocessor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Coprocessor() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_Coprocessor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Coprocessor(::grpc::ServerContext* /*context*/, const ::coprocessor::Request* /*request*/, ::coprocessor::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCoprocessor(::grpc::ServerContext* context, ::coprocessor::Request* request, ::grpc::ServerAsyncResponseWriter< ::coprocessor::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_KvGet<WithAsyncMethod_KvScan<WithAsyncMethod_KvPrewrite<WithAsyncMethod_KvCommit<WithAsyncMethod_KvCheckTxnStatus<WithAsyncMethod_KvBatchRollback<WithAsyncMethod_KvResolveLock<WithAsyncMethod_TransferLeader<WithAsyncMethod_PeerConfChange<WithAsyncMethod_SplitRegion<WithAsyncMethod_RawGet<WithAsyncMethod_RawPut<WithAsyncMethod_RawDelete<WithAsyncMethod_RawScan<WithAsyncMethod_Raft<WithAsyncMethod_Snapshot<WithAsyncMethod_Coprocessor<Service > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_KvGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_KvGet() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::GetRequest, ::kvrpcpb::GetResponse>(
          [this](::grpc::ServerContext* context,
                 const ::kvrpcpb::GetRequest* request,
                 ::kvrpcpb::GetResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->KvGet(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_KvGet(
        ::grpc::experimental::MessageAllocator< ::kvrpcpb::GetRequest, ::kvrpcpb::GetResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::GetRequest, ::kvrpcpb::GetResponse>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_KvGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGet(::grpc::ServerContext* /*context*/, const ::kvrpcpb::GetRequest* /*request*/, ::kvrpcpb::GetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void KvGet(::grpc::ServerContext* /*context*/, const ::kvrpcpb::GetRequest* /*request*/, ::kvrpcpb::GetResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_KvScan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_KvScan() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::ScanRequest, ::kvrpcpb::ScanResponse>(
          [this](::grpc::ServerContext* context,
                 const ::kvrpcpb::ScanRequest* request,
                 ::kvrpcpb::ScanResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->KvScan(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_KvScan(
        ::grpc::experimental::MessageAllocator< ::kvrpcpb::ScanRequest, ::kvrpcpb::ScanResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::ScanRequest, ::kvrpcpb::ScanResponse>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_KvScan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvScan(::grpc::ServerContext* /*context*/, const ::kvrpcpb::ScanRequest* /*request*/, ::kvrpcpb::ScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void KvScan(::grpc::ServerContext* /*context*/, const ::kvrpcpb::ScanRequest* /*request*/, ::kvrpcpb::ScanResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_KvPrewrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_KvPrewrite() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::PrewriteRequest, ::kvrpcpb::PrewriteResponse>(
          [this](::grpc::ServerContext* context,
                 const ::kvrpcpb::PrewriteRequest* request,
                 ::kvrpcpb::PrewriteResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->KvPrewrite(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_KvPrewrite(
        ::grpc::experimental::MessageAllocator< ::kvrpcpb::PrewriteRequest, ::kvrpcpb::PrewriteResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::PrewriteRequest, ::kvrpcpb::PrewriteResponse>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_KvPrewrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvPrewrite(::grpc::ServerContext* /*context*/, const ::kvrpcpb::PrewriteRequest* /*request*/, ::kvrpcpb::PrewriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void KvPrewrite(::grpc::ServerContext* /*context*/, const ::kvrpcpb::PrewriteRequest* /*request*/, ::kvrpcpb::PrewriteResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_KvCommit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_KvCommit() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::CommitRequest, ::kvrpcpb::CommitResponse>(
          [this](::grpc::ServerContext* context,
                 const ::kvrpcpb::CommitRequest* request,
                 ::kvrpcpb::CommitResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->KvCommit(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_KvCommit(
        ::grpc::experimental::MessageAllocator< ::kvrpcpb::CommitRequest, ::kvrpcpb::CommitResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::CommitRequest, ::kvrpcpb::CommitResponse>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_KvCommit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvCommit(::grpc::ServerContext* /*context*/, const ::kvrpcpb::CommitRequest* /*request*/, ::kvrpcpb::CommitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void KvCommit(::grpc::ServerContext* /*context*/, const ::kvrpcpb::CommitRequest* /*request*/, ::kvrpcpb::CommitResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_KvCheckTxnStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_KvCheckTxnStatus() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::CheckTxnStatusRequest, ::kvrpcpb::CheckTxnStatusResponse>(
          [this](::grpc::ServerContext* context,
                 const ::kvrpcpb::CheckTxnStatusRequest* request,
                 ::kvrpcpb::CheckTxnStatusResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->KvCheckTxnStatus(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_KvCheckTxnStatus(
        ::grpc::experimental::MessageAllocator< ::kvrpcpb::CheckTxnStatusRequest, ::kvrpcpb::CheckTxnStatusResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::CheckTxnStatusRequest, ::kvrpcpb::CheckTxnStatusResponse>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_KvCheckTxnStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvCheckTxnStatus(::grpc::ServerContext* /*context*/, const ::kvrpcpb::CheckTxnStatusRequest* /*request*/, ::kvrpcpb::CheckTxnStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void KvCheckTxnStatus(::grpc::ServerContext* /*context*/, const ::kvrpcpb::CheckTxnStatusRequest* /*request*/, ::kvrpcpb::CheckTxnStatusResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_KvBatchRollback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_KvBatchRollback() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::BatchRollbackRequest, ::kvrpcpb::BatchRollbackResponse>(
          [this](::grpc::ServerContext* context,
                 const ::kvrpcpb::BatchRollbackRequest* request,
                 ::kvrpcpb::BatchRollbackResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->KvBatchRollback(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_KvBatchRollback(
        ::grpc::experimental::MessageAllocator< ::kvrpcpb::BatchRollbackRequest, ::kvrpcpb::BatchRollbackResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::BatchRollbackRequest, ::kvrpcpb::BatchRollbackResponse>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_KvBatchRollback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBatchRollback(::grpc::ServerContext* /*context*/, const ::kvrpcpb::BatchRollbackRequest* /*request*/, ::kvrpcpb::BatchRollbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void KvBatchRollback(::grpc::ServerContext* /*context*/, const ::kvrpcpb::BatchRollbackRequest* /*request*/, ::kvrpcpb::BatchRollbackResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_KvResolveLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_KvResolveLock() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::ResolveLockRequest, ::kvrpcpb::ResolveLockResponse>(
          [this](::grpc::ServerContext* context,
                 const ::kvrpcpb::ResolveLockRequest* request,
                 ::kvrpcpb::ResolveLockResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->KvResolveLock(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_KvResolveLock(
        ::grpc::experimental::MessageAllocator< ::kvrpcpb::ResolveLockRequest, ::kvrpcpb::ResolveLockResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::ResolveLockRequest, ::kvrpcpb::ResolveLockResponse>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_KvResolveLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvResolveLock(::grpc::ServerContext* /*context*/, const ::kvrpcpb::ResolveLockRequest* /*request*/, ::kvrpcpb::ResolveLockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void KvResolveLock(::grpc::ServerContext* /*context*/, const ::kvrpcpb::ResolveLockRequest* /*request*/, ::kvrpcpb::ResolveLockResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TransferLeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TransferLeader() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::raft_cmdpb::TransferLeaderRequest, ::raft_cmdpb::TransferLeaderResponse>(
          [this](::grpc::ServerContext* context,
                 const ::raft_cmdpb::TransferLeaderRequest* request,
                 ::raft_cmdpb::TransferLeaderResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->TransferLeader(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_TransferLeader(
        ::grpc::experimental::MessageAllocator< ::raft_cmdpb::TransferLeaderRequest, ::raft_cmdpb::TransferLeaderResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::raft_cmdpb::TransferLeaderRequest, ::raft_cmdpb::TransferLeaderResponse>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TransferLeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferLeader(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::TransferLeaderRequest* /*request*/, ::raft_cmdpb::TransferLeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void TransferLeader(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::TransferLeaderRequest* /*request*/, ::raft_cmdpb::TransferLeaderResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PeerConfChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PeerConfChange() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::raft_cmdpb::ChangePeerRequest, ::raft_cmdpb::ChangePeerResponse>(
          [this](::grpc::ServerContext* context,
                 const ::raft_cmdpb::ChangePeerRequest* request,
                 ::raft_cmdpb::ChangePeerResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->PeerConfChange(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_PeerConfChange(
        ::grpc::experimental::MessageAllocator< ::raft_cmdpb::ChangePeerRequest, ::raft_cmdpb::ChangePeerResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::raft_cmdpb::ChangePeerRequest, ::raft_cmdpb::ChangePeerResponse>*>(
          ::grpc::Service::experimental().GetHandler(8))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PeerConfChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerConfChange(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::ChangePeerRequest* /*request*/, ::raft_cmdpb::ChangePeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void PeerConfChange(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::ChangePeerRequest* /*request*/, ::raft_cmdpb::ChangePeerResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SplitRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SplitRegion() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::raft_cmdpb::SplitRequest, ::raft_cmdpb::SplitResponse>(
          [this](::grpc::ServerContext* context,
                 const ::raft_cmdpb::SplitRequest* request,
                 ::raft_cmdpb::SplitResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SplitRegion(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SplitRegion(
        ::grpc::experimental::MessageAllocator< ::raft_cmdpb::SplitRequest, ::raft_cmdpb::SplitResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::raft_cmdpb::SplitRequest, ::raft_cmdpb::SplitResponse>*>(
          ::grpc::Service::experimental().GetHandler(9))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SplitRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SplitRegion(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::SplitRequest* /*request*/, ::raft_cmdpb::SplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SplitRegion(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::SplitRequest* /*request*/, ::raft_cmdpb::SplitResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RawGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RawGet() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::RawGetRequest, ::kvrpcpb::RawGetResponse>(
          [this](::grpc::ServerContext* context,
                 const ::kvrpcpb::RawGetRequest* request,
                 ::kvrpcpb::RawGetResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->RawGet(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_RawGet(
        ::grpc::experimental::MessageAllocator< ::kvrpcpb::RawGetRequest, ::kvrpcpb::RawGetResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::RawGetRequest, ::kvrpcpb::RawGetResponse>*>(
          ::grpc::Service::experimental().GetHandler(10))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RawGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawGet(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawGetRequest* /*request*/, ::kvrpcpb::RawGetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RawGet(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawGetRequest* /*request*/, ::kvrpcpb::RawGetResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RawPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RawPut() {
      ::grpc::Service::experimental().MarkMethodCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::RawPutRequest, ::kvrpcpb::RawPutResponse>(
          [this](::grpc::ServerContext* context,
                 const ::kvrpcpb::RawPutRequest* request,
                 ::kvrpcpb::RawPutResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->RawPut(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_RawPut(
        ::grpc::experimental::MessageAllocator< ::kvrpcpb::RawPutRequest, ::kvrpcpb::RawPutResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::RawPutRequest, ::kvrpcpb::RawPutResponse>*>(
          ::grpc::Service::experimental().GetHandler(11))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RawPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawPut(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawPutRequest* /*request*/, ::kvrpcpb::RawPutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RawPut(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawPutRequest* /*request*/, ::kvrpcpb::RawPutResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RawDelete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RawDelete() {
      ::grpc::Service::experimental().MarkMethodCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::RawDeleteRequest, ::kvrpcpb::RawDeleteResponse>(
          [this](::grpc::ServerContext* context,
                 const ::kvrpcpb::RawDeleteRequest* request,
                 ::kvrpcpb::RawDeleteResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->RawDelete(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_RawDelete(
        ::grpc::experimental::MessageAllocator< ::kvrpcpb::RawDeleteRequest, ::kvrpcpb::RawDeleteResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::RawDeleteRequest, ::kvrpcpb::RawDeleteResponse>*>(
          ::grpc::Service::experimental().GetHandler(12))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RawDelete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawDelete(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawDeleteRequest* /*request*/, ::kvrpcpb::RawDeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RawDelete(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawDeleteRequest* /*request*/, ::kvrpcpb::RawDeleteResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RawScan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RawScan() {
      ::grpc::Service::experimental().MarkMethodCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::RawScanRequest, ::kvrpcpb::RawScanResponse>(
          [this](::grpc::ServerContext* context,
                 const ::kvrpcpb::RawScanRequest* request,
                 ::kvrpcpb::RawScanResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->RawScan(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_RawScan(
        ::grpc::experimental::MessageAllocator< ::kvrpcpb::RawScanRequest, ::kvrpcpb::RawScanResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::kvrpcpb::RawScanRequest, ::kvrpcpb::RawScanResponse>*>(
          ::grpc::Service::experimental().GetHandler(13))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RawScan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawScan(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawScanRequest* /*request*/, ::kvrpcpb::RawScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RawScan(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawScanRequest* /*request*/, ::kvrpcpb::RawScanResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Raft : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Raft() {
      ::grpc::Service::experimental().MarkMethodCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::raft_serverpb::RaftMessage, ::raft_serverpb::Done>(
          [this](::grpc::ServerContext* context,
                 const ::raft_serverpb::RaftMessage* request,
                 ::raft_serverpb::Done* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Raft(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Raft(
        ::grpc::experimental::MessageAllocator< ::raft_serverpb::RaftMessage, ::raft_serverpb::Done>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::raft_serverpb::RaftMessage, ::raft_serverpb::Done>*>(
          ::grpc::Service::experimental().GetHandler(14))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Raft() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Raft(::grpc::ServerContext* /*context*/, const ::raft_serverpb::RaftMessage* /*request*/, ::raft_serverpb::Done* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Raft(::grpc::ServerContext* /*context*/, const ::raft_serverpb::RaftMessage* /*request*/, ::raft_serverpb::Done* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Snapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Snapshot() {
      ::grpc::Service::experimental().MarkMethodCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::raft_serverpb::SnapshotChunk, ::raft_serverpb::Done>(
          [this](::grpc::ServerContext* context,
                 const ::raft_serverpb::SnapshotChunk* request,
                 ::raft_serverpb::Done* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Snapshot(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Snapshot(
        ::grpc::experimental::MessageAllocator< ::raft_serverpb::SnapshotChunk, ::raft_serverpb::Done>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::raft_serverpb::SnapshotChunk, ::raft_serverpb::Done>*>(
          ::grpc::Service::experimental().GetHandler(15))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Snapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Snapshot(::grpc::ServerContext* /*context*/, const ::raft_serverpb::SnapshotChunk* /*request*/, ::raft_serverpb::Done* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Snapshot(::grpc::ServerContext* /*context*/, const ::raft_serverpb::SnapshotChunk* /*request*/, ::raft_serverpb::Done* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Coprocessor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Coprocessor() {
      ::grpc::Service::experimental().MarkMethodCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::coprocessor::Request, ::coprocessor::Response>(
          [this](::grpc::ServerContext* context,
                 const ::coprocessor::Request* request,
                 ::coprocessor::Response* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Coprocessor(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Coprocessor(
        ::grpc::experimental::MessageAllocator< ::coprocessor::Request, ::coprocessor::Response>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::coprocessor::Request, ::coprocessor::Response>*>(
          ::grpc::Service::experimental().GetHandler(16))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Coprocessor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Coprocessor(::grpc::ServerContext* /*context*/, const ::coprocessor::Request* /*request*/, ::coprocessor::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Coprocessor(::grpc::ServerContext* /*context*/, const ::coprocessor::Request* /*request*/, ::coprocessor::Response* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_KvGet<ExperimentalWithCallbackMethod_KvScan<ExperimentalWithCallbackMethod_KvPrewrite<ExperimentalWithCallbackMethod_KvCommit<ExperimentalWithCallbackMethod_KvCheckTxnStatus<ExperimentalWithCallbackMethod_KvBatchRollback<ExperimentalWithCallbackMethod_KvResolveLock<ExperimentalWithCallbackMethod_TransferLeader<ExperimentalWithCallbackMethod_PeerConfChange<ExperimentalWithCallbackMethod_SplitRegion<ExperimentalWithCallbackMethod_RawGet<ExperimentalWithCallbackMethod_RawPut<ExperimentalWithCallbackMethod_RawDelete<ExperimentalWithCallbackMethod_RawScan<ExperimentalWithCallbackMethod_Raft<ExperimentalWithCallbackMethod_Snapshot<ExperimentalWithCallbackMethod_Coprocessor<Service > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_KvGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KvGet() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_KvGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGet(::grpc::ServerContext* /*context*/, const ::kvrpcpb::GetRequest* /*request*/, ::kvrpcpb::GetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KvScan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KvScan() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_KvScan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvScan(::grpc::ServerContext* /*context*/, const ::kvrpcpb::ScanRequest* /*request*/, ::kvrpcpb::ScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KvPrewrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KvPrewrite() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_KvPrewrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvPrewrite(::grpc::ServerContext* /*context*/, const ::kvrpcpb::PrewriteRequest* /*request*/, ::kvrpcpb::PrewriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KvCommit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KvCommit() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_KvCommit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvCommit(::grpc::ServerContext* /*context*/, const ::kvrpcpb::CommitRequest* /*request*/, ::kvrpcpb::CommitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KvCheckTxnStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KvCheckTxnStatus() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_KvCheckTxnStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvCheckTxnStatus(::grpc::ServerContext* /*context*/, const ::kvrpcpb::CheckTxnStatusRequest* /*request*/, ::kvrpcpb::CheckTxnStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KvBatchRollback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KvBatchRollback() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_KvBatchRollback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBatchRollback(::grpc::ServerContext* /*context*/, const ::kvrpcpb::BatchRollbackRequest* /*request*/, ::kvrpcpb::BatchRollbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KvResolveLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KvResolveLock() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_KvResolveLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvResolveLock(::grpc::ServerContext* /*context*/, const ::kvrpcpb::ResolveLockRequest* /*request*/, ::kvrpcpb::ResolveLockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TransferLeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TransferLeader() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_TransferLeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferLeader(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::TransferLeaderRequest* /*request*/, ::raft_cmdpb::TransferLeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PeerConfChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PeerConfChange() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_PeerConfChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerConfChange(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::ChangePeerRequest* /*request*/, ::raft_cmdpb::ChangePeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SplitRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SplitRegion() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_SplitRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SplitRegion(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::SplitRequest* /*request*/, ::raft_cmdpb::SplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RawGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RawGet() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_RawGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawGet(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawGetRequest* /*request*/, ::kvrpcpb::RawGetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RawPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RawPut() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_RawPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawPut(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawPutRequest* /*request*/, ::kvrpcpb::RawPutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RawDelete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RawDelete() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_RawDelete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawDelete(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawDeleteRequest* /*request*/, ::kvrpcpb::RawDeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RawScan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RawScan() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_RawScan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawScan(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawScanRequest* /*request*/, ::kvrpcpb::RawScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Raft : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Raft() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_Raft() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Raft(::grpc::ServerContext* /*context*/, const ::raft_serverpb::RaftMessage* /*request*/, ::raft_serverpb::Done* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Snapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Snapshot() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_Snapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Snapshot(::grpc::ServerContext* /*context*/, const ::raft_serverpb::SnapshotChunk* /*request*/, ::raft_serverpb::Done* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Coprocessor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Coprocessor() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_Coprocessor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Coprocessor(::grpc::ServerContext* /*context*/, const ::coprocessor::Request* /*request*/, ::coprocessor::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_KvGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KvGet() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_KvGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGet(::grpc::ServerContext* /*context*/, const ::kvrpcpb::GetRequest* /*request*/, ::kvrpcpb::GetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvGet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KvScan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KvScan() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_KvScan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvScan(::grpc::ServerContext* /*context*/, const ::kvrpcpb::ScanRequest* /*request*/, ::kvrpcpb::ScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvScan(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KvPrewrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KvPrewrite() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_KvPrewrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvPrewrite(::grpc::ServerContext* /*context*/, const ::kvrpcpb::PrewriteRequest* /*request*/, ::kvrpcpb::PrewriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvPrewrite(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KvCommit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KvCommit() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_KvCommit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvCommit(::grpc::ServerContext* /*context*/, const ::kvrpcpb::CommitRequest* /*request*/, ::kvrpcpb::CommitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvCommit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KvCheckTxnStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KvCheckTxnStatus() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_KvCheckTxnStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvCheckTxnStatus(::grpc::ServerContext* /*context*/, const ::kvrpcpb::CheckTxnStatusRequest* /*request*/, ::kvrpcpb::CheckTxnStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvCheckTxnStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KvBatchRollback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KvBatchRollback() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_KvBatchRollback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBatchRollback(::grpc::ServerContext* /*context*/, const ::kvrpcpb::BatchRollbackRequest* /*request*/, ::kvrpcpb::BatchRollbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvBatchRollback(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KvResolveLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KvResolveLock() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_KvResolveLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvResolveLock(::grpc::ServerContext* /*context*/, const ::kvrpcpb::ResolveLockRequest* /*request*/, ::kvrpcpb::ResolveLockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvResolveLock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TransferLeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TransferLeader() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_TransferLeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferLeader(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::TransferLeaderRequest* /*request*/, ::raft_cmdpb::TransferLeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransferLeader(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PeerConfChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PeerConfChange() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_PeerConfChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerConfChange(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::ChangePeerRequest* /*request*/, ::raft_cmdpb::ChangePeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPeerConfChange(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SplitRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SplitRegion() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_SplitRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SplitRegion(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::SplitRequest* /*request*/, ::raft_cmdpb::SplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSplitRegion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RawGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RawGet() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_RawGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawGet(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawGetRequest* /*request*/, ::kvrpcpb::RawGetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRawGet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RawPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RawPut() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_RawPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawPut(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawPutRequest* /*request*/, ::kvrpcpb::RawPutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRawPut(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RawDelete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RawDelete() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_RawDelete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawDelete(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawDeleteRequest* /*request*/, ::kvrpcpb::RawDeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRawDelete(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RawScan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RawScan() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_RawScan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawScan(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawScanRequest* /*request*/, ::kvrpcpb::RawScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRawScan(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Raft : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Raft() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_Raft() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Raft(::grpc::ServerContext* /*context*/, const ::raft_serverpb::RaftMessage* /*request*/, ::raft_serverpb::Done* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRaft(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Snapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Snapshot() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_Snapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Snapshot(::grpc::ServerContext* /*context*/, const ::raft_serverpb::SnapshotChunk* /*request*/, ::raft_serverpb::Done* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSnapshot(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Coprocessor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Coprocessor() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_Coprocessor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Coprocessor(::grpc::ServerContext* /*context*/, const ::coprocessor::Request* /*request*/, ::coprocessor::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCoprocessor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_KvGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_KvGet() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->KvGet(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_KvGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGet(::grpc::ServerContext* /*context*/, const ::kvrpcpb::GetRequest* /*request*/, ::kvrpcpb::GetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void KvGet(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_KvScan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_KvScan() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->KvScan(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_KvScan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvScan(::grpc::ServerContext* /*context*/, const ::kvrpcpb::ScanRequest* /*request*/, ::kvrpcpb::ScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void KvScan(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_KvPrewrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_KvPrewrite() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->KvPrewrite(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_KvPrewrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvPrewrite(::grpc::ServerContext* /*context*/, const ::kvrpcpb::PrewriteRequest* /*request*/, ::kvrpcpb::PrewriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void KvPrewrite(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_KvCommit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_KvCommit() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->KvCommit(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_KvCommit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvCommit(::grpc::ServerContext* /*context*/, const ::kvrpcpb::CommitRequest* /*request*/, ::kvrpcpb::CommitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void KvCommit(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_KvCheckTxnStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_KvCheckTxnStatus() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->KvCheckTxnStatus(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_KvCheckTxnStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvCheckTxnStatus(::grpc::ServerContext* /*context*/, const ::kvrpcpb::CheckTxnStatusRequest* /*request*/, ::kvrpcpb::CheckTxnStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void KvCheckTxnStatus(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_KvBatchRollback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_KvBatchRollback() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->KvBatchRollback(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_KvBatchRollback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBatchRollback(::grpc::ServerContext* /*context*/, const ::kvrpcpb::BatchRollbackRequest* /*request*/, ::kvrpcpb::BatchRollbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void KvBatchRollback(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_KvResolveLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_KvResolveLock() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->KvResolveLock(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_KvResolveLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvResolveLock(::grpc::ServerContext* /*context*/, const ::kvrpcpb::ResolveLockRequest* /*request*/, ::kvrpcpb::ResolveLockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void KvResolveLock(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TransferLeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TransferLeader() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->TransferLeader(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_TransferLeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferLeader(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::TransferLeaderRequest* /*request*/, ::raft_cmdpb::TransferLeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void TransferLeader(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PeerConfChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PeerConfChange() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->PeerConfChange(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_PeerConfChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PeerConfChange(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::ChangePeerRequest* /*request*/, ::raft_cmdpb::ChangePeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void PeerConfChange(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SplitRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SplitRegion() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SplitRegion(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SplitRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SplitRegion(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::SplitRequest* /*request*/, ::raft_cmdpb::SplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SplitRegion(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RawGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RawGet() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->RawGet(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_RawGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawGet(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawGetRequest* /*request*/, ::kvrpcpb::RawGetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RawGet(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RawPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RawPut() {
      ::grpc::Service::experimental().MarkMethodRawCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->RawPut(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_RawPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawPut(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawPutRequest* /*request*/, ::kvrpcpb::RawPutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RawPut(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RawDelete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RawDelete() {
      ::grpc::Service::experimental().MarkMethodRawCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->RawDelete(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_RawDelete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawDelete(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawDeleteRequest* /*request*/, ::kvrpcpb::RawDeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RawDelete(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RawScan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RawScan() {
      ::grpc::Service::experimental().MarkMethodRawCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->RawScan(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_RawScan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RawScan(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawScanRequest* /*request*/, ::kvrpcpb::RawScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RawScan(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Raft : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Raft() {
      ::grpc::Service::experimental().MarkMethodRawCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Raft(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Raft() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Raft(::grpc::ServerContext* /*context*/, const ::raft_serverpb::RaftMessage* /*request*/, ::raft_serverpb::Done* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Raft(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Snapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Snapshot() {
      ::grpc::Service::experimental().MarkMethodRawCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Snapshot(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Snapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Snapshot(::grpc::ServerContext* /*context*/, const ::raft_serverpb::SnapshotChunk* /*request*/, ::raft_serverpb::Done* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Snapshot(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Coprocessor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Coprocessor() {
      ::grpc::Service::experimental().MarkMethodRawCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Coprocessor(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Coprocessor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Coprocessor(::grpc::ServerContext* /*context*/, const ::coprocessor::Request* /*request*/, ::coprocessor::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Coprocessor(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KvGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KvGet() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::kvrpcpb::GetRequest, ::kvrpcpb::GetResponse>(std::bind(&WithStreamedUnaryMethod_KvGet<BaseClass>::StreamedKvGet, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_KvGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KvGet(::grpc::ServerContext* /*context*/, const ::kvrpcpb::GetRequest* /*request*/, ::kvrpcpb::GetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKvGet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kvrpcpb::GetRequest,::kvrpcpb::GetResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KvScan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KvScan() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::kvrpcpb::ScanRequest, ::kvrpcpb::ScanResponse>(std::bind(&WithStreamedUnaryMethod_KvScan<BaseClass>::StreamedKvScan, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_KvScan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KvScan(::grpc::ServerContext* /*context*/, const ::kvrpcpb::ScanRequest* /*request*/, ::kvrpcpb::ScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKvScan(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kvrpcpb::ScanRequest,::kvrpcpb::ScanResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KvPrewrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KvPrewrite() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::kvrpcpb::PrewriteRequest, ::kvrpcpb::PrewriteResponse>(std::bind(&WithStreamedUnaryMethod_KvPrewrite<BaseClass>::StreamedKvPrewrite, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_KvPrewrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KvPrewrite(::grpc::ServerContext* /*context*/, const ::kvrpcpb::PrewriteRequest* /*request*/, ::kvrpcpb::PrewriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKvPrewrite(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kvrpcpb::PrewriteRequest,::kvrpcpb::PrewriteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KvCommit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KvCommit() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::kvrpcpb::CommitRequest, ::kvrpcpb::CommitResponse>(std::bind(&WithStreamedUnaryMethod_KvCommit<BaseClass>::StreamedKvCommit, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_KvCommit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KvCommit(::grpc::ServerContext* /*context*/, const ::kvrpcpb::CommitRequest* /*request*/, ::kvrpcpb::CommitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKvCommit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kvrpcpb::CommitRequest,::kvrpcpb::CommitResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KvCheckTxnStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KvCheckTxnStatus() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::kvrpcpb::CheckTxnStatusRequest, ::kvrpcpb::CheckTxnStatusResponse>(std::bind(&WithStreamedUnaryMethod_KvCheckTxnStatus<BaseClass>::StreamedKvCheckTxnStatus, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_KvCheckTxnStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KvCheckTxnStatus(::grpc::ServerContext* /*context*/, const ::kvrpcpb::CheckTxnStatusRequest* /*request*/, ::kvrpcpb::CheckTxnStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKvCheckTxnStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kvrpcpb::CheckTxnStatusRequest,::kvrpcpb::CheckTxnStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KvBatchRollback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KvBatchRollback() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::kvrpcpb::BatchRollbackRequest, ::kvrpcpb::BatchRollbackResponse>(std::bind(&WithStreamedUnaryMethod_KvBatchRollback<BaseClass>::StreamedKvBatchRollback, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_KvBatchRollback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KvBatchRollback(::grpc::ServerContext* /*context*/, const ::kvrpcpb::BatchRollbackRequest* /*request*/, ::kvrpcpb::BatchRollbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKvBatchRollback(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kvrpcpb::BatchRollbackRequest,::kvrpcpb::BatchRollbackResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KvResolveLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KvResolveLock() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::kvrpcpb::ResolveLockRequest, ::kvrpcpb::ResolveLockResponse>(std::bind(&WithStreamedUnaryMethod_KvResolveLock<BaseClass>::StreamedKvResolveLock, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_KvResolveLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KvResolveLock(::grpc::ServerContext* /*context*/, const ::kvrpcpb::ResolveLockRequest* /*request*/, ::kvrpcpb::ResolveLockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKvResolveLock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kvrpcpb::ResolveLockRequest,::kvrpcpb::ResolveLockResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TransferLeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TransferLeader() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::raft_cmdpb::TransferLeaderRequest, ::raft_cmdpb::TransferLeaderResponse>(std::bind(&WithStreamedUnaryMethod_TransferLeader<BaseClass>::StreamedTransferLeader, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_TransferLeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TransferLeader(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::TransferLeaderRequest* /*request*/, ::raft_cmdpb::TransferLeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTransferLeader(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::raft_cmdpb::TransferLeaderRequest,::raft_cmdpb::TransferLeaderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PeerConfChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PeerConfChange() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::raft_cmdpb::ChangePeerRequest, ::raft_cmdpb::ChangePeerResponse>(std::bind(&WithStreamedUnaryMethod_PeerConfChange<BaseClass>::StreamedPeerConfChange, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PeerConfChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PeerConfChange(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::ChangePeerRequest* /*request*/, ::raft_cmdpb::ChangePeerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPeerConfChange(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::raft_cmdpb::ChangePeerRequest,::raft_cmdpb::ChangePeerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SplitRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SplitRegion() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::raft_cmdpb::SplitRequest, ::raft_cmdpb::SplitResponse>(std::bind(&WithStreamedUnaryMethod_SplitRegion<BaseClass>::StreamedSplitRegion, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SplitRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SplitRegion(::grpc::ServerContext* /*context*/, const ::raft_cmdpb::SplitRequest* /*request*/, ::raft_cmdpb::SplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSplitRegion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::raft_cmdpb::SplitRequest,::raft_cmdpb::SplitResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RawGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RawGet() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::kvrpcpb::RawGetRequest, ::kvrpcpb::RawGetResponse>(std::bind(&WithStreamedUnaryMethod_RawGet<BaseClass>::StreamedRawGet, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RawGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RawGet(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawGetRequest* /*request*/, ::kvrpcpb::RawGetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRawGet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kvrpcpb::RawGetRequest,::kvrpcpb::RawGetResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RawPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RawPut() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::kvrpcpb::RawPutRequest, ::kvrpcpb::RawPutResponse>(std::bind(&WithStreamedUnaryMethod_RawPut<BaseClass>::StreamedRawPut, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RawPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RawPut(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawPutRequest* /*request*/, ::kvrpcpb::RawPutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRawPut(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kvrpcpb::RawPutRequest,::kvrpcpb::RawPutResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RawDelete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RawDelete() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::kvrpcpb::RawDeleteRequest, ::kvrpcpb::RawDeleteResponse>(std::bind(&WithStreamedUnaryMethod_RawDelete<BaseClass>::StreamedRawDelete, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RawDelete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RawDelete(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawDeleteRequest* /*request*/, ::kvrpcpb::RawDeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRawDelete(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kvrpcpb::RawDeleteRequest,::kvrpcpb::RawDeleteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RawScan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RawScan() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::kvrpcpb::RawScanRequest, ::kvrpcpb::RawScanResponse>(std::bind(&WithStreamedUnaryMethod_RawScan<BaseClass>::StreamedRawScan, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RawScan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RawScan(::grpc::ServerContext* /*context*/, const ::kvrpcpb::RawScanRequest* /*request*/, ::kvrpcpb::RawScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRawScan(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kvrpcpb::RawScanRequest,::kvrpcpb::RawScanResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Raft : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Raft() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::raft_serverpb::RaftMessage, ::raft_serverpb::Done>(std::bind(&WithStreamedUnaryMethod_Raft<BaseClass>::StreamedRaft, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Raft() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Raft(::grpc::ServerContext* /*context*/, const ::raft_serverpb::RaftMessage* /*request*/, ::raft_serverpb::Done* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRaft(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::raft_serverpb::RaftMessage,::raft_serverpb::Done>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Snapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Snapshot() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::raft_serverpb::SnapshotChunk, ::raft_serverpb::Done>(std::bind(&WithStreamedUnaryMethod_Snapshot<BaseClass>::StreamedSnapshot, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Snapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Snapshot(::grpc::ServerContext* /*context*/, const ::raft_serverpb::SnapshotChunk* /*request*/, ::raft_serverpb::Done* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSnapshot(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::raft_serverpb::SnapshotChunk,::raft_serverpb::Done>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Coprocessor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Coprocessor() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::coprocessor::Request, ::coprocessor::Response>(std::bind(&WithStreamedUnaryMethod_Coprocessor<BaseClass>::StreamedCoprocessor, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Coprocessor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Coprocessor(::grpc::ServerContext* /*context*/, const ::coprocessor::Request* /*request*/, ::coprocessor::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCoprocessor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::coprocessor::Request,::coprocessor::Response>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_KvGet<WithStreamedUnaryMethod_KvScan<WithStreamedUnaryMethod_KvPrewrite<WithStreamedUnaryMethod_KvCommit<WithStreamedUnaryMethod_KvCheckTxnStatus<WithStreamedUnaryMethod_KvBatchRollback<WithStreamedUnaryMethod_KvResolveLock<WithStreamedUnaryMethod_TransferLeader<WithStreamedUnaryMethod_PeerConfChange<WithStreamedUnaryMethod_SplitRegion<WithStreamedUnaryMethod_RawGet<WithStreamedUnaryMethod_RawPut<WithStreamedUnaryMethod_RawDelete<WithStreamedUnaryMethod_RawScan<WithStreamedUnaryMethod_Raft<WithStreamedUnaryMethod_Snapshot<WithStreamedUnaryMethod_Coprocessor<Service > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_KvGet<WithStreamedUnaryMethod_KvScan<WithStreamedUnaryMethod_KvPrewrite<WithStreamedUnaryMethod_KvCommit<WithStreamedUnaryMethod_KvCheckTxnStatus<WithStreamedUnaryMethod_KvBatchRollback<WithStreamedUnaryMethod_KvResolveLock<WithStreamedUnaryMethod_TransferLeader<WithStreamedUnaryMethod_PeerConfChange<WithStreamedUnaryMethod_SplitRegion<WithStreamedUnaryMethod_RawGet<WithStreamedUnaryMethod_RawPut<WithStreamedUnaryMethod_RawDelete<WithStreamedUnaryMethod_RawScan<WithStreamedUnaryMethod_Raft<WithStreamedUnaryMethod_Snapshot<WithStreamedUnaryMethod_Coprocessor<Service > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace tinykvpb


#endif  // GRPC_tinykvpb_2eproto__INCLUDED
