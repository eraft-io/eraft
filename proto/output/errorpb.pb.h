// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: errorpb.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_errorpb_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_errorpb_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "metapb.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_errorpb_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_errorpb_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_errorpb_2eproto;
namespace errorpb {
class EpochNotMatch;
class EpochNotMatchDefaultTypeInternal;
extern EpochNotMatchDefaultTypeInternal _EpochNotMatch_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class KeyNotInRegion;
class KeyNotInRegionDefaultTypeInternal;
extern KeyNotInRegionDefaultTypeInternal _KeyNotInRegion_default_instance_;
class NotLeader;
class NotLeaderDefaultTypeInternal;
extern NotLeaderDefaultTypeInternal _NotLeader_default_instance_;
class RegionNotFound;
class RegionNotFoundDefaultTypeInternal;
extern RegionNotFoundDefaultTypeInternal _RegionNotFound_default_instance_;
class StaleCommand;
class StaleCommandDefaultTypeInternal;
extern StaleCommandDefaultTypeInternal _StaleCommand_default_instance_;
class StoreNotMatch;
class StoreNotMatchDefaultTypeInternal;
extern StoreNotMatchDefaultTypeInternal _StoreNotMatch_default_instance_;
}  // namespace errorpb
PROTOBUF_NAMESPACE_OPEN
template<> ::errorpb::EpochNotMatch* Arena::CreateMaybeMessage<::errorpb::EpochNotMatch>(Arena*);
template<> ::errorpb::Error* Arena::CreateMaybeMessage<::errorpb::Error>(Arena*);
template<> ::errorpb::KeyNotInRegion* Arena::CreateMaybeMessage<::errorpb::KeyNotInRegion>(Arena*);
template<> ::errorpb::NotLeader* Arena::CreateMaybeMessage<::errorpb::NotLeader>(Arena*);
template<> ::errorpb::RegionNotFound* Arena::CreateMaybeMessage<::errorpb::RegionNotFound>(Arena*);
template<> ::errorpb::StaleCommand* Arena::CreateMaybeMessage<::errorpb::StaleCommand>(Arena*);
template<> ::errorpb::StoreNotMatch* Arena::CreateMaybeMessage<::errorpb::StoreNotMatch>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace errorpb {

// ===================================================================

class NotLeader PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:errorpb.NotLeader) */ {
 public:
  inline NotLeader() : NotLeader(nullptr) {}
  virtual ~NotLeader();

  NotLeader(const NotLeader& from);
  NotLeader(NotLeader&& from) noexcept
    : NotLeader() {
    *this = ::std::move(from);
  }

  inline NotLeader& operator=(const NotLeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotLeader& operator=(NotLeader&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NotLeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NotLeader* internal_default_instance() {
    return reinterpret_cast<const NotLeader*>(
               &_NotLeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NotLeader& a, NotLeader& b) {
    a.Swap(&b);
  }
  inline void Swap(NotLeader* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotLeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NotLeader* New() const final {
    return CreateMaybeMessage<NotLeader>(nullptr);
  }

  NotLeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NotLeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NotLeader& from);
  void MergeFrom(const NotLeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotLeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "errorpb.NotLeader";
  }
  protected:
  explicit NotLeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_errorpb_2eproto);
    return ::descriptor_table_errorpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaderFieldNumber = 2,
    kRegionIdFieldNumber = 1,
  };
  // .metapb.Peer leader = 2;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const ::metapb::Peer& leader() const;
  ::metapb::Peer* release_leader();
  ::metapb::Peer* mutable_leader();
  void set_allocated_leader(::metapb::Peer* leader);
  private:
  const ::metapb::Peer& _internal_leader() const;
  ::metapb::Peer* _internal_mutable_leader();
  public:
  void unsafe_arena_set_allocated_leader(
      ::metapb::Peer* leader);
  ::metapb::Peer* unsafe_arena_release_leader();

  // uint64 region_id = 1;
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:errorpb.NotLeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::metapb::Peer* leader_;
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_errorpb_2eproto;
};
// -------------------------------------------------------------------

class StoreNotMatch PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:errorpb.StoreNotMatch) */ {
 public:
  inline StoreNotMatch() : StoreNotMatch(nullptr) {}
  virtual ~StoreNotMatch();

  StoreNotMatch(const StoreNotMatch& from);
  StoreNotMatch(StoreNotMatch&& from) noexcept
    : StoreNotMatch() {
    *this = ::std::move(from);
  }

  inline StoreNotMatch& operator=(const StoreNotMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreNotMatch& operator=(StoreNotMatch&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StoreNotMatch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StoreNotMatch* internal_default_instance() {
    return reinterpret_cast<const StoreNotMatch*>(
               &_StoreNotMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StoreNotMatch& a, StoreNotMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreNotMatch* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreNotMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StoreNotMatch* New() const final {
    return CreateMaybeMessage<StoreNotMatch>(nullptr);
  }

  StoreNotMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StoreNotMatch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StoreNotMatch& from);
  void MergeFrom(const StoreNotMatch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreNotMatch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "errorpb.StoreNotMatch";
  }
  protected:
  explicit StoreNotMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_errorpb_2eproto);
    return ::descriptor_table_errorpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestStoreIdFieldNumber = 1,
    kActualStoreIdFieldNumber = 2,
  };
  // uint64 request_store_id = 1;
  void clear_request_store_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_store_id() const;
  void set_request_store_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_store_id() const;
  void _internal_set_request_store_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 actual_store_id = 2;
  void clear_actual_store_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 actual_store_id() const;
  void set_actual_store_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_actual_store_id() const;
  void _internal_set_actual_store_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:errorpb.StoreNotMatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_store_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 actual_store_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_errorpb_2eproto;
};
// -------------------------------------------------------------------

class RegionNotFound PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:errorpb.RegionNotFound) */ {
 public:
  inline RegionNotFound() : RegionNotFound(nullptr) {}
  virtual ~RegionNotFound();

  RegionNotFound(const RegionNotFound& from);
  RegionNotFound(RegionNotFound&& from) noexcept
    : RegionNotFound() {
    *this = ::std::move(from);
  }

  inline RegionNotFound& operator=(const RegionNotFound& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionNotFound& operator=(RegionNotFound&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegionNotFound& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionNotFound* internal_default_instance() {
    return reinterpret_cast<const RegionNotFound*>(
               &_RegionNotFound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RegionNotFound& a, RegionNotFound& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionNotFound* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionNotFound* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionNotFound* New() const final {
    return CreateMaybeMessage<RegionNotFound>(nullptr);
  }

  RegionNotFound* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionNotFound>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegionNotFound& from);
  void MergeFrom(const RegionNotFound& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionNotFound* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "errorpb.RegionNotFound";
  }
  protected:
  explicit RegionNotFound(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_errorpb_2eproto);
    return ::descriptor_table_errorpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
  };
  // uint64 region_id = 1;
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:errorpb.RegionNotFound)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_errorpb_2eproto;
};
// -------------------------------------------------------------------

class KeyNotInRegion PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:errorpb.KeyNotInRegion) */ {
 public:
  inline KeyNotInRegion() : KeyNotInRegion(nullptr) {}
  virtual ~KeyNotInRegion();

  KeyNotInRegion(const KeyNotInRegion& from);
  KeyNotInRegion(KeyNotInRegion&& from) noexcept
    : KeyNotInRegion() {
    *this = ::std::move(from);
  }

  inline KeyNotInRegion& operator=(const KeyNotInRegion& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyNotInRegion& operator=(KeyNotInRegion&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KeyNotInRegion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyNotInRegion* internal_default_instance() {
    return reinterpret_cast<const KeyNotInRegion*>(
               &_KeyNotInRegion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(KeyNotInRegion& a, KeyNotInRegion& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyNotInRegion* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyNotInRegion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyNotInRegion* New() const final {
    return CreateMaybeMessage<KeyNotInRegion>(nullptr);
  }

  KeyNotInRegion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyNotInRegion>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeyNotInRegion& from);
  void MergeFrom(const KeyNotInRegion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyNotInRegion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "errorpb.KeyNotInRegion";
  }
  protected:
  explicit KeyNotInRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_errorpb_2eproto);
    return ::descriptor_table_errorpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kStartKeyFieldNumber = 3,
    kEndKeyFieldNumber = 4,
    kRegionIdFieldNumber = 2,
  };
  // bytes key = 1;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes start_key = 3;
  void clear_start_key();
  const std::string& start_key() const;
  void set_start_key(const std::string& value);
  void set_start_key(std::string&& value);
  void set_start_key(const char* value);
  void set_start_key(const void* value, size_t size);
  std::string* mutable_start_key();
  std::string* release_start_key();
  void set_allocated_start_key(std::string* start_key);
  private:
  const std::string& _internal_start_key() const;
  void _internal_set_start_key(const std::string& value);
  std::string* _internal_mutable_start_key();
  public:

  // bytes end_key = 4;
  void clear_end_key();
  const std::string& end_key() const;
  void set_end_key(const std::string& value);
  void set_end_key(std::string&& value);
  void set_end_key(const char* value);
  void set_end_key(const void* value, size_t size);
  std::string* mutable_end_key();
  std::string* release_end_key();
  void set_allocated_end_key(std::string* end_key);
  private:
  const std::string& _internal_end_key() const;
  void _internal_set_end_key(const std::string& value);
  std::string* _internal_mutable_end_key();
  public:

  // uint64 region_id = 2;
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:errorpb.KeyNotInRegion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_key_;
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_errorpb_2eproto;
};
// -------------------------------------------------------------------

class EpochNotMatch PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:errorpb.EpochNotMatch) */ {
 public:
  inline EpochNotMatch() : EpochNotMatch(nullptr) {}
  virtual ~EpochNotMatch();

  EpochNotMatch(const EpochNotMatch& from);
  EpochNotMatch(EpochNotMatch&& from) noexcept
    : EpochNotMatch() {
    *this = ::std::move(from);
  }

  inline EpochNotMatch& operator=(const EpochNotMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpochNotMatch& operator=(EpochNotMatch&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EpochNotMatch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EpochNotMatch* internal_default_instance() {
    return reinterpret_cast<const EpochNotMatch*>(
               &_EpochNotMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EpochNotMatch& a, EpochNotMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(EpochNotMatch* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpochNotMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EpochNotMatch* New() const final {
    return CreateMaybeMessage<EpochNotMatch>(nullptr);
  }

  EpochNotMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EpochNotMatch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EpochNotMatch& from);
  void MergeFrom(const EpochNotMatch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpochNotMatch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "errorpb.EpochNotMatch";
  }
  protected:
  explicit EpochNotMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_errorpb_2eproto);
    return ::descriptor_table_errorpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentRegionsFieldNumber = 1,
  };
  // repeated .metapb.Region current_regions = 1;
  int current_regions_size() const;
  private:
  int _internal_current_regions_size() const;
  public:
  void clear_current_regions();
  ::metapb::Region* mutable_current_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Region >*
      mutable_current_regions();
  private:
  const ::metapb::Region& _internal_current_regions(int index) const;
  ::metapb::Region* _internal_add_current_regions();
  public:
  const ::metapb::Region& current_regions(int index) const;
  ::metapb::Region* add_current_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Region >&
      current_regions() const;

  // @@protoc_insertion_point(class_scope:errorpb.EpochNotMatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Region > current_regions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_errorpb_2eproto;
};
// -------------------------------------------------------------------

class StaleCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:errorpb.StaleCommand) */ {
 public:
  inline StaleCommand() : StaleCommand(nullptr) {}
  virtual ~StaleCommand();

  StaleCommand(const StaleCommand& from);
  StaleCommand(StaleCommand&& from) noexcept
    : StaleCommand() {
    *this = ::std::move(from);
  }

  inline StaleCommand& operator=(const StaleCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaleCommand& operator=(StaleCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StaleCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StaleCommand* internal_default_instance() {
    return reinterpret_cast<const StaleCommand*>(
               &_StaleCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StaleCommand& a, StaleCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(StaleCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaleCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StaleCommand* New() const final {
    return CreateMaybeMessage<StaleCommand>(nullptr);
  }

  StaleCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StaleCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StaleCommand& from);
  void MergeFrom(const StaleCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaleCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "errorpb.StaleCommand";
  }
  protected:
  explicit StaleCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_errorpb_2eproto);
    return ::descriptor_table_errorpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:errorpb.StaleCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_errorpb_2eproto;
};
// -------------------------------------------------------------------

class Error PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:errorpb.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  virtual ~Error();

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Error& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const final {
    return CreateMaybeMessage<Error>(nullptr);
  }

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "errorpb.Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_errorpb_2eproto);
    return ::descriptor_table_errorpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kNotLeaderFieldNumber = 2,
    kRegionNotFoundFieldNumber = 3,
    kKeyNotInRegionFieldNumber = 4,
    kEpochNotMatchFieldNumber = 5,
    kStaleCommandFieldNumber = 7,
    kStoreNotMatchFieldNumber = 8,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .errorpb.NotLeader not_leader = 2;
  bool has_not_leader() const;
  private:
  bool _internal_has_not_leader() const;
  public:
  void clear_not_leader();
  const ::errorpb::NotLeader& not_leader() const;
  ::errorpb::NotLeader* release_not_leader();
  ::errorpb::NotLeader* mutable_not_leader();
  void set_allocated_not_leader(::errorpb::NotLeader* not_leader);
  private:
  const ::errorpb::NotLeader& _internal_not_leader() const;
  ::errorpb::NotLeader* _internal_mutable_not_leader();
  public:
  void unsafe_arena_set_allocated_not_leader(
      ::errorpb::NotLeader* not_leader);
  ::errorpb::NotLeader* unsafe_arena_release_not_leader();

  // .errorpb.RegionNotFound region_not_found = 3;
  bool has_region_not_found() const;
  private:
  bool _internal_has_region_not_found() const;
  public:
  void clear_region_not_found();
  const ::errorpb::RegionNotFound& region_not_found() const;
  ::errorpb::RegionNotFound* release_region_not_found();
  ::errorpb::RegionNotFound* mutable_region_not_found();
  void set_allocated_region_not_found(::errorpb::RegionNotFound* region_not_found);
  private:
  const ::errorpb::RegionNotFound& _internal_region_not_found() const;
  ::errorpb::RegionNotFound* _internal_mutable_region_not_found();
  public:
  void unsafe_arena_set_allocated_region_not_found(
      ::errorpb::RegionNotFound* region_not_found);
  ::errorpb::RegionNotFound* unsafe_arena_release_region_not_found();

  // .errorpb.KeyNotInRegion key_not_in_region = 4;
  bool has_key_not_in_region() const;
  private:
  bool _internal_has_key_not_in_region() const;
  public:
  void clear_key_not_in_region();
  const ::errorpb::KeyNotInRegion& key_not_in_region() const;
  ::errorpb::KeyNotInRegion* release_key_not_in_region();
  ::errorpb::KeyNotInRegion* mutable_key_not_in_region();
  void set_allocated_key_not_in_region(::errorpb::KeyNotInRegion* key_not_in_region);
  private:
  const ::errorpb::KeyNotInRegion& _internal_key_not_in_region() const;
  ::errorpb::KeyNotInRegion* _internal_mutable_key_not_in_region();
  public:
  void unsafe_arena_set_allocated_key_not_in_region(
      ::errorpb::KeyNotInRegion* key_not_in_region);
  ::errorpb::KeyNotInRegion* unsafe_arena_release_key_not_in_region();

  // .errorpb.EpochNotMatch epoch_not_match = 5;
  bool has_epoch_not_match() const;
  private:
  bool _internal_has_epoch_not_match() const;
  public:
  void clear_epoch_not_match();
  const ::errorpb::EpochNotMatch& epoch_not_match() const;
  ::errorpb::EpochNotMatch* release_epoch_not_match();
  ::errorpb::EpochNotMatch* mutable_epoch_not_match();
  void set_allocated_epoch_not_match(::errorpb::EpochNotMatch* epoch_not_match);
  private:
  const ::errorpb::EpochNotMatch& _internal_epoch_not_match() const;
  ::errorpb::EpochNotMatch* _internal_mutable_epoch_not_match();
  public:
  void unsafe_arena_set_allocated_epoch_not_match(
      ::errorpb::EpochNotMatch* epoch_not_match);
  ::errorpb::EpochNotMatch* unsafe_arena_release_epoch_not_match();

  // .errorpb.StaleCommand stale_command = 7;
  bool has_stale_command() const;
  private:
  bool _internal_has_stale_command() const;
  public:
  void clear_stale_command();
  const ::errorpb::StaleCommand& stale_command() const;
  ::errorpb::StaleCommand* release_stale_command();
  ::errorpb::StaleCommand* mutable_stale_command();
  void set_allocated_stale_command(::errorpb::StaleCommand* stale_command);
  private:
  const ::errorpb::StaleCommand& _internal_stale_command() const;
  ::errorpb::StaleCommand* _internal_mutable_stale_command();
  public:
  void unsafe_arena_set_allocated_stale_command(
      ::errorpb::StaleCommand* stale_command);
  ::errorpb::StaleCommand* unsafe_arena_release_stale_command();

  // .errorpb.StoreNotMatch store_not_match = 8;
  bool has_store_not_match() const;
  private:
  bool _internal_has_store_not_match() const;
  public:
  void clear_store_not_match();
  const ::errorpb::StoreNotMatch& store_not_match() const;
  ::errorpb::StoreNotMatch* release_store_not_match();
  ::errorpb::StoreNotMatch* mutable_store_not_match();
  void set_allocated_store_not_match(::errorpb::StoreNotMatch* store_not_match);
  private:
  const ::errorpb::StoreNotMatch& _internal_store_not_match() const;
  ::errorpb::StoreNotMatch* _internal_mutable_store_not_match();
  public:
  void unsafe_arena_set_allocated_store_not_match(
      ::errorpb::StoreNotMatch* store_not_match);
  ::errorpb::StoreNotMatch* unsafe_arena_release_store_not_match();

  // @@protoc_insertion_point(class_scope:errorpb.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::errorpb::NotLeader* not_leader_;
  ::errorpb::RegionNotFound* region_not_found_;
  ::errorpb::KeyNotInRegion* key_not_in_region_;
  ::errorpb::EpochNotMatch* epoch_not_match_;
  ::errorpb::StaleCommand* stale_command_;
  ::errorpb::StoreNotMatch* store_not_match_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_errorpb_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NotLeader

// uint64 region_id = 1;
inline void NotLeader::clear_region_id() {
  region_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NotLeader::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NotLeader::region_id() const {
  // @@protoc_insertion_point(field_get:errorpb.NotLeader.region_id)
  return _internal_region_id();
}
inline void NotLeader::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  region_id_ = value;
}
inline void NotLeader::set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:errorpb.NotLeader.region_id)
}

// .metapb.Peer leader = 2;
inline bool NotLeader::_internal_has_leader() const {
  return this != internal_default_instance() && leader_ != nullptr;
}
inline bool NotLeader::has_leader() const {
  return _internal_has_leader();
}
inline const ::metapb::Peer& NotLeader::_internal_leader() const {
  const ::metapb::Peer* p = leader_;
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline const ::metapb::Peer& NotLeader::leader() const {
  // @@protoc_insertion_point(field_get:errorpb.NotLeader.leader)
  return _internal_leader();
}
inline void NotLeader::unsafe_arena_set_allocated_leader(
    ::metapb::Peer* leader) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader_);
  }
  leader_ = leader;
  if (leader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:errorpb.NotLeader.leader)
}
inline ::metapb::Peer* NotLeader::release_leader() {
  
  ::metapb::Peer* temp = leader_;
  leader_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::metapb::Peer* NotLeader::unsafe_arena_release_leader() {
  // @@protoc_insertion_point(field_release:errorpb.NotLeader.leader)
  
  ::metapb::Peer* temp = leader_;
  leader_ = nullptr;
  return temp;
}
inline ::metapb::Peer* NotLeader::_internal_mutable_leader() {
  
  if (leader_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Peer>(GetArena());
    leader_ = p;
  }
  return leader_;
}
inline ::metapb::Peer* NotLeader::mutable_leader() {
  // @@protoc_insertion_point(field_mutable:errorpb.NotLeader.leader)
  return _internal_mutable_leader();
}
inline void NotLeader::set_allocated_leader(::metapb::Peer* leader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader_);
  }
  if (leader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader)->GetArena();
    if (message_arena != submessage_arena) {
      leader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leader, submessage_arena);
    }
    
  } else {
    
  }
  leader_ = leader;
  // @@protoc_insertion_point(field_set_allocated:errorpb.NotLeader.leader)
}

// -------------------------------------------------------------------

// StoreNotMatch

// uint64 request_store_id = 1;
inline void StoreNotMatch::clear_request_store_id() {
  request_store_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreNotMatch::_internal_request_store_id() const {
  return request_store_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreNotMatch::request_store_id() const {
  // @@protoc_insertion_point(field_get:errorpb.StoreNotMatch.request_store_id)
  return _internal_request_store_id();
}
inline void StoreNotMatch::_internal_set_request_store_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  request_store_id_ = value;
}
inline void StoreNotMatch::set_request_store_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_store_id(value);
  // @@protoc_insertion_point(field_set:errorpb.StoreNotMatch.request_store_id)
}

// uint64 actual_store_id = 2;
inline void StoreNotMatch::clear_actual_store_id() {
  actual_store_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreNotMatch::_internal_actual_store_id() const {
  return actual_store_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreNotMatch::actual_store_id() const {
  // @@protoc_insertion_point(field_get:errorpb.StoreNotMatch.actual_store_id)
  return _internal_actual_store_id();
}
inline void StoreNotMatch::_internal_set_actual_store_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  actual_store_id_ = value;
}
inline void StoreNotMatch::set_actual_store_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_actual_store_id(value);
  // @@protoc_insertion_point(field_set:errorpb.StoreNotMatch.actual_store_id)
}

// -------------------------------------------------------------------

// RegionNotFound

// uint64 region_id = 1;
inline void RegionNotFound::clear_region_id() {
  region_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionNotFound::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionNotFound::region_id() const {
  // @@protoc_insertion_point(field_get:errorpb.RegionNotFound.region_id)
  return _internal_region_id();
}
inline void RegionNotFound::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  region_id_ = value;
}
inline void RegionNotFound::set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:errorpb.RegionNotFound.region_id)
}

// -------------------------------------------------------------------

// KeyNotInRegion

// bytes key = 1;
inline void KeyNotInRegion::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& KeyNotInRegion::key() const {
  // @@protoc_insertion_point(field_get:errorpb.KeyNotInRegion.key)
  return _internal_key();
}
inline void KeyNotInRegion::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:errorpb.KeyNotInRegion.key)
}
inline std::string* KeyNotInRegion::mutable_key() {
  // @@protoc_insertion_point(field_mutable:errorpb.KeyNotInRegion.key)
  return _internal_mutable_key();
}
inline const std::string& KeyNotInRegion::_internal_key() const {
  return key_.Get();
}
inline void KeyNotInRegion::_internal_set_key(const std::string& value) {
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void KeyNotInRegion::set_key(std::string&& value) {
  
  key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:errorpb.KeyNotInRegion.key)
}
inline void KeyNotInRegion::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:errorpb.KeyNotInRegion.key)
}
inline void KeyNotInRegion::set_key(const void* value,
    size_t size) {
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:errorpb.KeyNotInRegion.key)
}
inline std::string* KeyNotInRegion::_internal_mutable_key() {
  
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* KeyNotInRegion::release_key() {
  // @@protoc_insertion_point(field_release:errorpb.KeyNotInRegion.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void KeyNotInRegion::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:errorpb.KeyNotInRegion.key)
}

// uint64 region_id = 2;
inline void KeyNotInRegion::clear_region_id() {
  region_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KeyNotInRegion::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KeyNotInRegion::region_id() const {
  // @@protoc_insertion_point(field_get:errorpb.KeyNotInRegion.region_id)
  return _internal_region_id();
}
inline void KeyNotInRegion::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  region_id_ = value;
}
inline void KeyNotInRegion::set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:errorpb.KeyNotInRegion.region_id)
}

// bytes start_key = 3;
inline void KeyNotInRegion::clear_start_key() {
  start_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& KeyNotInRegion::start_key() const {
  // @@protoc_insertion_point(field_get:errorpb.KeyNotInRegion.start_key)
  return _internal_start_key();
}
inline void KeyNotInRegion::set_start_key(const std::string& value) {
  _internal_set_start_key(value);
  // @@protoc_insertion_point(field_set:errorpb.KeyNotInRegion.start_key)
}
inline std::string* KeyNotInRegion::mutable_start_key() {
  // @@protoc_insertion_point(field_mutable:errorpb.KeyNotInRegion.start_key)
  return _internal_mutable_start_key();
}
inline const std::string& KeyNotInRegion::_internal_start_key() const {
  return start_key_.Get();
}
inline void KeyNotInRegion::_internal_set_start_key(const std::string& value) {
  
  start_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void KeyNotInRegion::set_start_key(std::string&& value) {
  
  start_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:errorpb.KeyNotInRegion.start_key)
}
inline void KeyNotInRegion::set_start_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  start_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:errorpb.KeyNotInRegion.start_key)
}
inline void KeyNotInRegion::set_start_key(const void* value,
    size_t size) {
  
  start_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:errorpb.KeyNotInRegion.start_key)
}
inline std::string* KeyNotInRegion::_internal_mutable_start_key() {
  
  return start_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* KeyNotInRegion::release_start_key() {
  // @@protoc_insertion_point(field_release:errorpb.KeyNotInRegion.start_key)
  return start_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void KeyNotInRegion::set_allocated_start_key(std::string* start_key) {
  if (start_key != nullptr) {
    
  } else {
    
  }
  start_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), start_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:errorpb.KeyNotInRegion.start_key)
}

// bytes end_key = 4;
inline void KeyNotInRegion::clear_end_key() {
  end_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& KeyNotInRegion::end_key() const {
  // @@protoc_insertion_point(field_get:errorpb.KeyNotInRegion.end_key)
  return _internal_end_key();
}
inline void KeyNotInRegion::set_end_key(const std::string& value) {
  _internal_set_end_key(value);
  // @@protoc_insertion_point(field_set:errorpb.KeyNotInRegion.end_key)
}
inline std::string* KeyNotInRegion::mutable_end_key() {
  // @@protoc_insertion_point(field_mutable:errorpb.KeyNotInRegion.end_key)
  return _internal_mutable_end_key();
}
inline const std::string& KeyNotInRegion::_internal_end_key() const {
  return end_key_.Get();
}
inline void KeyNotInRegion::_internal_set_end_key(const std::string& value) {
  
  end_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void KeyNotInRegion::set_end_key(std::string&& value) {
  
  end_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:errorpb.KeyNotInRegion.end_key)
}
inline void KeyNotInRegion::set_end_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  end_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:errorpb.KeyNotInRegion.end_key)
}
inline void KeyNotInRegion::set_end_key(const void* value,
    size_t size) {
  
  end_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:errorpb.KeyNotInRegion.end_key)
}
inline std::string* KeyNotInRegion::_internal_mutable_end_key() {
  
  return end_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* KeyNotInRegion::release_end_key() {
  // @@protoc_insertion_point(field_release:errorpb.KeyNotInRegion.end_key)
  return end_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void KeyNotInRegion::set_allocated_end_key(std::string* end_key) {
  if (end_key != nullptr) {
    
  } else {
    
  }
  end_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), end_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:errorpb.KeyNotInRegion.end_key)
}

// -------------------------------------------------------------------

// EpochNotMatch

// repeated .metapb.Region current_regions = 1;
inline int EpochNotMatch::_internal_current_regions_size() const {
  return current_regions_.size();
}
inline int EpochNotMatch::current_regions_size() const {
  return _internal_current_regions_size();
}
inline ::metapb::Region* EpochNotMatch::mutable_current_regions(int index) {
  // @@protoc_insertion_point(field_mutable:errorpb.EpochNotMatch.current_regions)
  return current_regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Region >*
EpochNotMatch::mutable_current_regions() {
  // @@protoc_insertion_point(field_mutable_list:errorpb.EpochNotMatch.current_regions)
  return &current_regions_;
}
inline const ::metapb::Region& EpochNotMatch::_internal_current_regions(int index) const {
  return current_regions_.Get(index);
}
inline const ::metapb::Region& EpochNotMatch::current_regions(int index) const {
  // @@protoc_insertion_point(field_get:errorpb.EpochNotMatch.current_regions)
  return _internal_current_regions(index);
}
inline ::metapb::Region* EpochNotMatch::_internal_add_current_regions() {
  return current_regions_.Add();
}
inline ::metapb::Region* EpochNotMatch::add_current_regions() {
  // @@protoc_insertion_point(field_add:errorpb.EpochNotMatch.current_regions)
  return _internal_add_current_regions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Region >&
EpochNotMatch::current_regions() const {
  // @@protoc_insertion_point(field_list:errorpb.EpochNotMatch.current_regions)
  return current_regions_;
}

// -------------------------------------------------------------------

// StaleCommand

// -------------------------------------------------------------------

// Error

// string message = 1;
inline void Error::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:errorpb.Error.message)
  return _internal_message();
}
inline void Error::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:errorpb.Error.message)
}
inline std::string* Error::mutable_message() {
  // @@protoc_insertion_point(field_mutable:errorpb.Error.message)
  return _internal_mutable_message();
}
inline const std::string& Error::_internal_message() const {
  return message_.Get();
}
inline void Error::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Error::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:errorpb.Error.message)
}
inline void Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:errorpb.Error.message)
}
inline void Error::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:errorpb.Error.message)
}
inline std::string* Error::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:errorpb.Error.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.message)
}

// .errorpb.NotLeader not_leader = 2;
inline bool Error::_internal_has_not_leader() const {
  return this != internal_default_instance() && not_leader_ != nullptr;
}
inline bool Error::has_not_leader() const {
  return _internal_has_not_leader();
}
inline void Error::clear_not_leader() {
  if (GetArena() == nullptr && not_leader_ != nullptr) {
    delete not_leader_;
  }
  not_leader_ = nullptr;
}
inline const ::errorpb::NotLeader& Error::_internal_not_leader() const {
  const ::errorpb::NotLeader* p = not_leader_;
  return p != nullptr ? *p : *reinterpret_cast<const ::errorpb::NotLeader*>(
      &::errorpb::_NotLeader_default_instance_);
}
inline const ::errorpb::NotLeader& Error::not_leader() const {
  // @@protoc_insertion_point(field_get:errorpb.Error.not_leader)
  return _internal_not_leader();
}
inline void Error::unsafe_arena_set_allocated_not_leader(
    ::errorpb::NotLeader* not_leader) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(not_leader_);
  }
  not_leader_ = not_leader;
  if (not_leader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:errorpb.Error.not_leader)
}
inline ::errorpb::NotLeader* Error::release_not_leader() {
  
  ::errorpb::NotLeader* temp = not_leader_;
  not_leader_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::errorpb::NotLeader* Error::unsafe_arena_release_not_leader() {
  // @@protoc_insertion_point(field_release:errorpb.Error.not_leader)
  
  ::errorpb::NotLeader* temp = not_leader_;
  not_leader_ = nullptr;
  return temp;
}
inline ::errorpb::NotLeader* Error::_internal_mutable_not_leader() {
  
  if (not_leader_ == nullptr) {
    auto* p = CreateMaybeMessage<::errorpb::NotLeader>(GetArena());
    not_leader_ = p;
  }
  return not_leader_;
}
inline ::errorpb::NotLeader* Error::mutable_not_leader() {
  // @@protoc_insertion_point(field_mutable:errorpb.Error.not_leader)
  return _internal_mutable_not_leader();
}
inline void Error::set_allocated_not_leader(::errorpb::NotLeader* not_leader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete not_leader_;
  }
  if (not_leader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(not_leader);
    if (message_arena != submessage_arena) {
      not_leader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, not_leader, submessage_arena);
    }
    
  } else {
    
  }
  not_leader_ = not_leader;
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.not_leader)
}

// .errorpb.RegionNotFound region_not_found = 3;
inline bool Error::_internal_has_region_not_found() const {
  return this != internal_default_instance() && region_not_found_ != nullptr;
}
inline bool Error::has_region_not_found() const {
  return _internal_has_region_not_found();
}
inline void Error::clear_region_not_found() {
  if (GetArena() == nullptr && region_not_found_ != nullptr) {
    delete region_not_found_;
  }
  region_not_found_ = nullptr;
}
inline const ::errorpb::RegionNotFound& Error::_internal_region_not_found() const {
  const ::errorpb::RegionNotFound* p = region_not_found_;
  return p != nullptr ? *p : *reinterpret_cast<const ::errorpb::RegionNotFound*>(
      &::errorpb::_RegionNotFound_default_instance_);
}
inline const ::errorpb::RegionNotFound& Error::region_not_found() const {
  // @@protoc_insertion_point(field_get:errorpb.Error.region_not_found)
  return _internal_region_not_found();
}
inline void Error::unsafe_arena_set_allocated_region_not_found(
    ::errorpb::RegionNotFound* region_not_found) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_not_found_);
  }
  region_not_found_ = region_not_found;
  if (region_not_found) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:errorpb.Error.region_not_found)
}
inline ::errorpb::RegionNotFound* Error::release_region_not_found() {
  
  ::errorpb::RegionNotFound* temp = region_not_found_;
  region_not_found_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::errorpb::RegionNotFound* Error::unsafe_arena_release_region_not_found() {
  // @@protoc_insertion_point(field_release:errorpb.Error.region_not_found)
  
  ::errorpb::RegionNotFound* temp = region_not_found_;
  region_not_found_ = nullptr;
  return temp;
}
inline ::errorpb::RegionNotFound* Error::_internal_mutable_region_not_found() {
  
  if (region_not_found_ == nullptr) {
    auto* p = CreateMaybeMessage<::errorpb::RegionNotFound>(GetArena());
    region_not_found_ = p;
  }
  return region_not_found_;
}
inline ::errorpb::RegionNotFound* Error::mutable_region_not_found() {
  // @@protoc_insertion_point(field_mutable:errorpb.Error.region_not_found)
  return _internal_mutable_region_not_found();
}
inline void Error::set_allocated_region_not_found(::errorpb::RegionNotFound* region_not_found) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete region_not_found_;
  }
  if (region_not_found) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(region_not_found);
    if (message_arena != submessage_arena) {
      region_not_found = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_not_found, submessage_arena);
    }
    
  } else {
    
  }
  region_not_found_ = region_not_found;
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.region_not_found)
}

// .errorpb.KeyNotInRegion key_not_in_region = 4;
inline bool Error::_internal_has_key_not_in_region() const {
  return this != internal_default_instance() && key_not_in_region_ != nullptr;
}
inline bool Error::has_key_not_in_region() const {
  return _internal_has_key_not_in_region();
}
inline void Error::clear_key_not_in_region() {
  if (GetArena() == nullptr && key_not_in_region_ != nullptr) {
    delete key_not_in_region_;
  }
  key_not_in_region_ = nullptr;
}
inline const ::errorpb::KeyNotInRegion& Error::_internal_key_not_in_region() const {
  const ::errorpb::KeyNotInRegion* p = key_not_in_region_;
  return p != nullptr ? *p : *reinterpret_cast<const ::errorpb::KeyNotInRegion*>(
      &::errorpb::_KeyNotInRegion_default_instance_);
}
inline const ::errorpb::KeyNotInRegion& Error::key_not_in_region() const {
  // @@protoc_insertion_point(field_get:errorpb.Error.key_not_in_region)
  return _internal_key_not_in_region();
}
inline void Error::unsafe_arena_set_allocated_key_not_in_region(
    ::errorpb::KeyNotInRegion* key_not_in_region) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_not_in_region_);
  }
  key_not_in_region_ = key_not_in_region;
  if (key_not_in_region) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:errorpb.Error.key_not_in_region)
}
inline ::errorpb::KeyNotInRegion* Error::release_key_not_in_region() {
  
  ::errorpb::KeyNotInRegion* temp = key_not_in_region_;
  key_not_in_region_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::errorpb::KeyNotInRegion* Error::unsafe_arena_release_key_not_in_region() {
  // @@protoc_insertion_point(field_release:errorpb.Error.key_not_in_region)
  
  ::errorpb::KeyNotInRegion* temp = key_not_in_region_;
  key_not_in_region_ = nullptr;
  return temp;
}
inline ::errorpb::KeyNotInRegion* Error::_internal_mutable_key_not_in_region() {
  
  if (key_not_in_region_ == nullptr) {
    auto* p = CreateMaybeMessage<::errorpb::KeyNotInRegion>(GetArena());
    key_not_in_region_ = p;
  }
  return key_not_in_region_;
}
inline ::errorpb::KeyNotInRegion* Error::mutable_key_not_in_region() {
  // @@protoc_insertion_point(field_mutable:errorpb.Error.key_not_in_region)
  return _internal_mutable_key_not_in_region();
}
inline void Error::set_allocated_key_not_in_region(::errorpb::KeyNotInRegion* key_not_in_region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete key_not_in_region_;
  }
  if (key_not_in_region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(key_not_in_region);
    if (message_arena != submessage_arena) {
      key_not_in_region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_not_in_region, submessage_arena);
    }
    
  } else {
    
  }
  key_not_in_region_ = key_not_in_region;
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.key_not_in_region)
}

// .errorpb.EpochNotMatch epoch_not_match = 5;
inline bool Error::_internal_has_epoch_not_match() const {
  return this != internal_default_instance() && epoch_not_match_ != nullptr;
}
inline bool Error::has_epoch_not_match() const {
  return _internal_has_epoch_not_match();
}
inline void Error::clear_epoch_not_match() {
  if (GetArena() == nullptr && epoch_not_match_ != nullptr) {
    delete epoch_not_match_;
  }
  epoch_not_match_ = nullptr;
}
inline const ::errorpb::EpochNotMatch& Error::_internal_epoch_not_match() const {
  const ::errorpb::EpochNotMatch* p = epoch_not_match_;
  return p != nullptr ? *p : *reinterpret_cast<const ::errorpb::EpochNotMatch*>(
      &::errorpb::_EpochNotMatch_default_instance_);
}
inline const ::errorpb::EpochNotMatch& Error::epoch_not_match() const {
  // @@protoc_insertion_point(field_get:errorpb.Error.epoch_not_match)
  return _internal_epoch_not_match();
}
inline void Error::unsafe_arena_set_allocated_epoch_not_match(
    ::errorpb::EpochNotMatch* epoch_not_match) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(epoch_not_match_);
  }
  epoch_not_match_ = epoch_not_match;
  if (epoch_not_match) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:errorpb.Error.epoch_not_match)
}
inline ::errorpb::EpochNotMatch* Error::release_epoch_not_match() {
  
  ::errorpb::EpochNotMatch* temp = epoch_not_match_;
  epoch_not_match_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::errorpb::EpochNotMatch* Error::unsafe_arena_release_epoch_not_match() {
  // @@protoc_insertion_point(field_release:errorpb.Error.epoch_not_match)
  
  ::errorpb::EpochNotMatch* temp = epoch_not_match_;
  epoch_not_match_ = nullptr;
  return temp;
}
inline ::errorpb::EpochNotMatch* Error::_internal_mutable_epoch_not_match() {
  
  if (epoch_not_match_ == nullptr) {
    auto* p = CreateMaybeMessage<::errorpb::EpochNotMatch>(GetArena());
    epoch_not_match_ = p;
  }
  return epoch_not_match_;
}
inline ::errorpb::EpochNotMatch* Error::mutable_epoch_not_match() {
  // @@protoc_insertion_point(field_mutable:errorpb.Error.epoch_not_match)
  return _internal_mutable_epoch_not_match();
}
inline void Error::set_allocated_epoch_not_match(::errorpb::EpochNotMatch* epoch_not_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete epoch_not_match_;
  }
  if (epoch_not_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(epoch_not_match);
    if (message_arena != submessage_arena) {
      epoch_not_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, epoch_not_match, submessage_arena);
    }
    
  } else {
    
  }
  epoch_not_match_ = epoch_not_match;
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.epoch_not_match)
}

// .errorpb.StaleCommand stale_command = 7;
inline bool Error::_internal_has_stale_command() const {
  return this != internal_default_instance() && stale_command_ != nullptr;
}
inline bool Error::has_stale_command() const {
  return _internal_has_stale_command();
}
inline void Error::clear_stale_command() {
  if (GetArena() == nullptr && stale_command_ != nullptr) {
    delete stale_command_;
  }
  stale_command_ = nullptr;
}
inline const ::errorpb::StaleCommand& Error::_internal_stale_command() const {
  const ::errorpb::StaleCommand* p = stale_command_;
  return p != nullptr ? *p : *reinterpret_cast<const ::errorpb::StaleCommand*>(
      &::errorpb::_StaleCommand_default_instance_);
}
inline const ::errorpb::StaleCommand& Error::stale_command() const {
  // @@protoc_insertion_point(field_get:errorpb.Error.stale_command)
  return _internal_stale_command();
}
inline void Error::unsafe_arena_set_allocated_stale_command(
    ::errorpb::StaleCommand* stale_command) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stale_command_);
  }
  stale_command_ = stale_command;
  if (stale_command) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:errorpb.Error.stale_command)
}
inline ::errorpb::StaleCommand* Error::release_stale_command() {
  
  ::errorpb::StaleCommand* temp = stale_command_;
  stale_command_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::errorpb::StaleCommand* Error::unsafe_arena_release_stale_command() {
  // @@protoc_insertion_point(field_release:errorpb.Error.stale_command)
  
  ::errorpb::StaleCommand* temp = stale_command_;
  stale_command_ = nullptr;
  return temp;
}
inline ::errorpb::StaleCommand* Error::_internal_mutable_stale_command() {
  
  if (stale_command_ == nullptr) {
    auto* p = CreateMaybeMessage<::errorpb::StaleCommand>(GetArena());
    stale_command_ = p;
  }
  return stale_command_;
}
inline ::errorpb::StaleCommand* Error::mutable_stale_command() {
  // @@protoc_insertion_point(field_mutable:errorpb.Error.stale_command)
  return _internal_mutable_stale_command();
}
inline void Error::set_allocated_stale_command(::errorpb::StaleCommand* stale_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stale_command_;
  }
  if (stale_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stale_command);
    if (message_arena != submessage_arena) {
      stale_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stale_command, submessage_arena);
    }
    
  } else {
    
  }
  stale_command_ = stale_command;
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.stale_command)
}

// .errorpb.StoreNotMatch store_not_match = 8;
inline bool Error::_internal_has_store_not_match() const {
  return this != internal_default_instance() && store_not_match_ != nullptr;
}
inline bool Error::has_store_not_match() const {
  return _internal_has_store_not_match();
}
inline void Error::clear_store_not_match() {
  if (GetArena() == nullptr && store_not_match_ != nullptr) {
    delete store_not_match_;
  }
  store_not_match_ = nullptr;
}
inline const ::errorpb::StoreNotMatch& Error::_internal_store_not_match() const {
  const ::errorpb::StoreNotMatch* p = store_not_match_;
  return p != nullptr ? *p : *reinterpret_cast<const ::errorpb::StoreNotMatch*>(
      &::errorpb::_StoreNotMatch_default_instance_);
}
inline const ::errorpb::StoreNotMatch& Error::store_not_match() const {
  // @@protoc_insertion_point(field_get:errorpb.Error.store_not_match)
  return _internal_store_not_match();
}
inline void Error::unsafe_arena_set_allocated_store_not_match(
    ::errorpb::StoreNotMatch* store_not_match) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(store_not_match_);
  }
  store_not_match_ = store_not_match;
  if (store_not_match) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:errorpb.Error.store_not_match)
}
inline ::errorpb::StoreNotMatch* Error::release_store_not_match() {
  
  ::errorpb::StoreNotMatch* temp = store_not_match_;
  store_not_match_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::errorpb::StoreNotMatch* Error::unsafe_arena_release_store_not_match() {
  // @@protoc_insertion_point(field_release:errorpb.Error.store_not_match)
  
  ::errorpb::StoreNotMatch* temp = store_not_match_;
  store_not_match_ = nullptr;
  return temp;
}
inline ::errorpb::StoreNotMatch* Error::_internal_mutable_store_not_match() {
  
  if (store_not_match_ == nullptr) {
    auto* p = CreateMaybeMessage<::errorpb::StoreNotMatch>(GetArena());
    store_not_match_ = p;
  }
  return store_not_match_;
}
inline ::errorpb::StoreNotMatch* Error::mutable_store_not_match() {
  // @@protoc_insertion_point(field_mutable:errorpb.Error.store_not_match)
  return _internal_mutable_store_not_match();
}
inline void Error::set_allocated_store_not_match(::errorpb::StoreNotMatch* store_not_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete store_not_match_;
  }
  if (store_not_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(store_not_match);
    if (message_arena != submessage_arena) {
      store_not_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, store_not_match, submessage_arena);
    }
    
  } else {
    
  }
  store_not_match_ = store_not_match;
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.store_not_match)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace errorpb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_errorpb_2eproto
