package shardctrler

//
// Shardctrler clerk.
//

import (
	"context"
	"crypto/rand"
	"fmt"
	"math/big"

	"github.com/eraft-io/eraft/labrpc"
	"github.com/eraft-io/eraft/shardctrlerpb"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

type Clerk struct {
	servers   []string
	clients   []shardctrlerpb.ShardCtrlerServiceClient
	leaderId  int64
	clientId  int64 // generated by nrand(), it would be better to use some distributed ID generation algorithm that guarantees no conflicts
	commandId int64 // (clientId, commandId) defines a operation uniquely
}

func nrand() int64 {
	max := big.NewInt(int64(1) << 62)
	bigx, _ := rand.Int(rand.Reader, max)
	return bigx.Int64()
}

func MakeClerk(servers []string) *Clerk {
	clients := make([]shardctrlerpb.ShardCtrlerServiceClient, len(servers))
	for i, addr := range servers {
		conn, err := grpc.Dial(addr, grpc.WithTransportCredentials(insecure.NewCredentials()))
		if err != nil {
			panic(err)
		}
		clients[i] = shardctrlerpb.NewShardCtrlerServiceClient(conn)
	}
	return &Clerk{
		servers:   servers,
		clients:   clients,
		leaderId:  0,
		clientId:  nrand(),
		commandId: 0,
	}
}

type LabrpcShardCtrlerClient struct {
	end *labrpc.ClientEnd
}

func (c *LabrpcShardCtrlerClient) Command(ctx context.Context, in *shardctrlerpb.CommandRequest, opts ...grpc.CallOption) (*shardctrlerpb.CommandResponse, error) {
	servers := make(map[int][]string)
	for gid, srvs := range in.Servers {
		servers[int(gid)] = srvs.Servers
	}
	gids := make([]int, len(in.Gids))
	for i, gid := range in.Gids {
		gids[i] = int(gid)
	}
	args := &CommandRequest{
		Servers:   servers,
		GIDs:      gids,
		Shard:     int(in.Shard),
		GID:       int(in.Gid),
		Num:       int(in.Num),
		Op:        OperationOp(in.Op),
		ClientId:  in.ClientId,
		CommandId: in.CommandId,
	}
	reply := &CommandResponse{}
	if ok := c.end.Call("ShardCtrler.Command", args, reply); ok {
		respConfig := &shardctrlerpb.Config{
			Num:    int64(reply.Config.Num),
			Shards: make([]int32, NShards),
			Groups: make(map[int32]*shardctrlerpb.Servers),
		}
		for i, gid := range reply.Config.Shards {
			respConfig.Shards[i] = int32(gid)
		}
		for gid, srvs := range reply.Config.Groups {
			respConfig.Groups[int32(gid)] = &shardctrlerpb.Servers{Servers: srvs}
		}
		return &shardctrlerpb.CommandResponse{
			Err:    reply.Err.String(),
			Config: respConfig,
		}, nil
	}
	return nil, fmt.Errorf("rpc failed")
}

func (c *LabrpcShardCtrlerClient) GetStatus(ctx context.Context, in *shardctrlerpb.GetStatusRequest, opts ...grpc.CallOption) (*shardctrlerpb.GetStatusResponse, error) {
	return nil, fmt.Errorf("GetStatus not supported in labrpc mode")
}

func MakeLabrpcClerk(servers []*labrpc.ClientEnd) *Clerk {
	clients := make([]shardctrlerpb.ShardCtrlerServiceClient, len(servers))
	for i, end := range servers {
		clients[i] = &LabrpcShardCtrlerClient{end: end}
	}
	addrs := make([]string, len(servers))
	return &Clerk{
		servers:   addrs,
		clients:   clients,
		leaderId:  0,
		clientId:  nrand(),
		commandId: 0,
	}
}

func (ck *Clerk) Query(num int) Config {
	return ck.Command(&CommandRequest{Num: num, Op: OpQuery})
}

func (ck *Clerk) Join(servers map[int][]string) {
	ck.Command(&CommandRequest{Servers: servers, Op: OpJoin})
}

func (ck *Clerk) Leave(gids []int) {
	ck.Command(&CommandRequest{GIDs: gids, Op: OpLeave})
}

func (ck *Clerk) Move(shard int, gid int) {
	ck.Command(&CommandRequest{Shard: shard, GID: gid, Op: OpMove})
}

func (ck *Clerk) GetStatus() (*shardctrlerpb.GetStatusResponse, error) {
	return ck.clients[ck.leaderId].GetStatus(context.Background(), &shardctrlerpb.GetStatusRequest{})
}

func (ck *Clerk) Command(request *CommandRequest) Config {
	request.ClientId, request.CommandId = ck.clientId, ck.commandId
	for {
		pbServers := make(map[int32]*shardctrlerpb.Servers)
		for gid, srvs := range request.Servers {
			pbServers[int32(gid)] = &shardctrlerpb.Servers{Servers: srvs}
		}

		pbGids := make([]int32, len(request.GIDs))
		for i, gid := range request.GIDs {
			pbGids[i] = int32(gid)
		}

		req := &shardctrlerpb.CommandRequest{
			Servers:   pbServers,
			Gids:      pbGids,
			Shard:     int32(request.Shard),
			Gid:       int32(request.GID),
			Num:       int32(request.Num),
			Op:        shardctrlerpb.Op(request.Op),
			ClientId:  request.ClientId,
			CommandId: request.CommandId,
		}
		ctx, cancel := context.WithTimeout(context.Background(), ExecuteTimeout)
		resp, err := ck.clients[ck.leaderId].Command(ctx, req)
		cancel()

		if err != nil || resp.Err == ErrWrongLeader.String() || resp.Err == ErrTimeout.String() {
			ck.leaderId = (ck.leaderId + 1) % int64(len(ck.servers))
			continue
		}
		ck.commandId++
		return shardctrlerpbConfigToConfig(resp.Config)
	}
}

func shardctrlerpbConfigToConfig(pb *shardctrlerpb.Config) Config {
	if pb == nil {
		return DefaultConfig()
	}
	config := Config{
		Num:    int(pb.Num),
		Groups: make(map[int][]string),
	}
	for i, gid := range pb.Shards {
		config.Shards[i] = int(gid)
	}
	for gid, srvs := range pb.Groups {
		config.Groups[int(gid)] = srvs.Servers
	}
	return config
}
