package kvraft

import (
	"context"
	"crypto/rand"
	"fmt"
	"math/big"
	"time"

	"github.com/eraft-io/eraft/kvraftpb"
	"github.com/eraft-io/eraft/labrpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

type Clerk struct {
	servers   []string
	clients   []kvraftpb.KVServiceClient
	leaderId  int64
	clientId  int64 // generated by nrand(), it would be better to use some distributed ID generation algorithm that guarantees no conflicts
	commandId int64 // (clientId, commandId) defines a operation uniquely
}

func nrand() int64 {
	max := big.NewInt(int64(1) << 62)
	bigx, _ := rand.Int(rand.Reader, max)
	return bigx.Int64()
}

func MakeClerk(servers []string) *Clerk {
	clients := make([]kvraftpb.KVServiceClient, len(servers))
	for i, addr := range servers {
		conn, err := grpc.Dial(addr, grpc.WithTransportCredentials(insecure.NewCredentials()))
		if err != nil {
			panic(err)
		}
		clients[i] = kvraftpb.NewKVServiceClient(conn)
	}
	return &Clerk{
		servers:   servers,
		clients:   clients,
		leaderId:  0,
		clientId:  nrand(),
		commandId: 0,
	}
}

type LabrpcKVClient struct {
	end *labrpc.ClientEnd
}

func (c *LabrpcKVClient) Command(ctx context.Context, in *kvraftpb.CommandRequest, opts ...grpc.CallOption) (*kvraftpb.CommandResponse, error) {
	args := &CommandRequest{
		Key:       in.Key,
		Value:     in.Value,
		Op:        OperationOp(in.Op),
		ClientId:  in.ClientId,
		CommandId: in.CommandId,
	}
	reply := &CommandResponse{}
	if ok := c.end.Call("KVServer.Command", args, reply); ok {
		return &kvraftpb.CommandResponse{
			Err:   reply.Err.String(),
			Value: reply.Value,
		}, nil
	}
	return nil, fmt.Errorf("rpc failed")
}

func (c *LabrpcKVClient) GetStatus(ctx context.Context, in *kvraftpb.GetStatusRequest, opts ...grpc.CallOption) (*kvraftpb.GetStatusResponse, error) {
	return nil, fmt.Errorf("GetStatus not supported in labrpc mode")
}

func MakeLabrpcClerk(servers []*labrpc.ClientEnd) *Clerk {
	clients := make([]kvraftpb.KVServiceClient, len(servers))
	for i, end := range servers {
		clients[i] = &LabrpcKVClient{end: end}
	}
	addrs := make([]string, len(servers))
	return &Clerk{
		servers:   addrs,
		clients:   clients,
		leaderId:  0,
		clientId:  nrand(),
		commandId: 0,
	}
}

func (ck *Clerk) Get(key string) string {
	return ck.Command(&CommandRequest{Key: key, Op: OpGet})
}

func (ck *Clerk) Put(key string, value string) {
	ck.Command(&CommandRequest{Key: key, Value: value, Op: OpPut})
}
func (ck *Clerk) Append(key string, value string) {
	ck.Command(&CommandRequest{Key: key, Value: value, Op: OpAppend})
}

func (ck *Clerk) GetStatus() []*kvraftpb.GetStatusResponse {
	results := make([]*kvraftpb.GetStatusResponse, len(ck.clients))
	for i, client := range ck.clients {
		ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
		resp, err := client.GetStatus(ctx, &kvraftpb.GetStatusRequest{})
		cancel()
		if err == nil {
			results[i] = resp
		} else {
			results[i] = &kvraftpb.GetStatusResponse{Id: int64(i), State: "Offline"}
		}
	}
	return results
}

// you can send an RPC with code like this:
// ok := ck.servers[i].Call("KVServer.Command", &request, &response)
//
// the types of args and reply (including whether they are pointers)
// must match the declared types of the RPC handler function's
// arguments. and reply must be passed as a pointer.
func (ck *Clerk) Command(request *CommandRequest) string {
	request.ClientId, request.CommandId = ck.clientId, ck.commandId
	for {
		req := &kvraftpb.CommandRequest{
			Key:       request.Key,
			Value:     request.Value,
			Op:        kvraftpb.Op(request.Op),
			ClientId:  request.ClientId,
			CommandId: request.CommandId,
		}
		ctx, cancel := context.WithTimeout(context.Background(), ExecuteTimeout)
		resp, err := ck.clients[ck.leaderId].Command(ctx, req)
		cancel()

		if err != nil || resp.Err == ErrWrongLeader.String() || resp.Err == ErrTimeout.String() {
			ck.leaderId = (ck.leaderId + 1) % int64(len(ck.servers))
			time.Sleep(10 * time.Millisecond) // Add a small delay to prevent tight loop
			continue
		}
		ck.commandId++
		return resp.Value
	}
}
